cpv_id,CPVINFO,pov_pou_info,private_test,bad_patch,good_patch,test_input
cpv1,"b""# Overview\r\n\r\nID: cpv1   \r\nType: [CWE-787](https://cwe.mitre.org/data/definitions/787.html) Out-of-bounds write   \r\nSanitizer: AddressSanitizer: heap-buffer-overflow   \r\n\r\n# Details\r\n\r\nThis CPV adds new functionality to the NGINX web server for handling the ``From`` HTTP header in incoming requests. This header is typically used to specify the email address of the user making the request. By introducing this capability, the patch allows NGINX to recognize, process, and validate the From header, ensuring that it adheres to a proper email address format.\r\n\r\n**Header Registration**: The ``ngx_http_headers_in`` array is updated to register the ``From`` header, mapping it to a new processing function, ``ngx_http_process_from``. This ensures that NGINX can correctly identify and route the ``From`` header to the appropriate handler.\r\n\r\n**Header Handling Logic**: A new function, ``ngx_http_process_from``, is implemented to handle the ``From`` header. This function checks for duplicate headers, validates the header value using ``the ngx_http_validate_from`` function, and assigns it to the request structure. If the ``From`` header is found to be invalid or duplicated, the function finalizes the request with a bad request error.\r\n\r\n**Validation Logic**: The ``ngx_http_validate_from`` function is introduced to ensure that the ``From`` header value conforms to a valid email address format. This function validates the presence of alphanumeric characters, the @ symbol, and a valid domain structure. It prevents malformed email addresses from being processed, thus enhancing the robustness of the request handling.\r\n\r\n**Request Structure Update**: The ``ngx_http_request_t`` structure in ``ngx_http_request.h`` is modified to include a new field for the ``From`` header (``ngx_table_elt_t *from``). This allows the header to be stored and accessed within the request's context.\r\n\r\n## Understanding the ``From`` Header\r\n\r\nThe ``From`` header in HTTP requests is used to indicate the email address of the user making the request. While not commonly used in modern web applications, this header can be useful for logging, analytics, and access control purposes. By validating and processing this header, NGINX can enhance its logging capabilities, allowing administrators to track requests based on user email addresses. This can be particularly useful in scenarios where user identification and auditing are important. For additional information see [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/From). \r\n\r\nThe injected vulnerability exists in the validation function. If a user has two ``..`` in a row the code attempts to remove one. However, if this is at the beginning of the email then there will be a buffer underrun and an attacker can write data to a buffer prior to the start of the string. \r\n\r\nThis is similar to an old bug in nginx but in a completely different section of code seen [here](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2629). Handling of a complex state machine can be difficult for something that is primarily generative and doesn't necessarily understand state. The parsing of the email is a fairly simple state machine but if a system is able to demonstrate that it could effectively recognize the coding pattern and detect the problem then this would be a success.\r\n""","b'pov_harness, AddressSanitizer: heap-buffer-overflow\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n\r\n# Tests for the prefer HTTP header\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nmy $t = Test::Nginx->new()->has(qw/http charset/)->plan(4);\r\n\r\n$t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->write_file(\'t1.html\', ""<html><body>Hello World</body></html>"");\r\n$t->run();\r\n###############################################################################\r\n\r\nmy $t1;\r\n\r\n$t1 = http_from(\'/t1.html\', \'From: test@test.com\');\r\nlike($t1, qr/ 200 /, \'from request - 200 OK\');\r\nlike($t1, qr/Content-Length: 37/, \'from request - correct length\');\r\nlike($t1, qr/Content-Type: text\\/html/, \'from request - correct type\');\r\n\r\n$t1 = http_from(\'/t1.html\', \'From: te@st@test.com\');\r\nlike($t1, qr/ 400 /, \'from request - 400 bad request\');\r\n\r\n###############################################################################\r\n\r\nsub http_from {\r\n\tmy ($url, $extra) = @_;\r\n\treturn http(<<EOF);\r\nGET $url HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n$extra\r\n\r\nEOF\r\n}\r\n\r\n###############################################################################\r\n'","b""diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c\r\nindex e6e6a34..f5b04a2 100644\r\n--- a/src/http/ngx_http_request.c\r\n+++ b/src/http/ngx_http_request.c\r\n@@ -4057,110 +4057,7 @@ ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\r\n static ngx_int_t\r\n ngx_http_validate_from(ngx_str_t *from, ngx_pool_t *pool, ngx_uint_t alloc)\r\n {\r\n-    u_char  *f, *u, ch;\r\n-    size_t   i;\r\n-\r\n-    enum {\r\n-        sw_begin = 0,\r\n-        sw_username,\r\n-        sw_username_dot,\r\n-        sw_domain,\r\n-        sw_tld\r\n-    } state;\r\n-\r\n-    f = from->data;\r\n-\r\n-    state = sw_begin;\r\n-\r\n-    if (alloc) {\r\n-        u = ngx_palloc(pool, from->len);\r\n-\r\n-        if (u == NULL) {\r\n-            return NGX_ERROR;\r\n-        }\r\n-    } else {\r\n-        u = from->data;\r\n-    }\r\n-\r\n-    for (i = 0; i < from->len; i++) {\r\n-        ch = f[i];\r\n-\r\n-        switch (state) {\r\n-\r\n-        case sw_begin:\r\n-            if (isalnum(ch) || ch == '-' || ch == '_') {\r\n-                state = sw_username;\r\n-            } else if (ch == '.') {\r\n-                state = sw_username_dot;\r\n-            } else {\r\n-                return NGX_DECLINED;\r\n-            }\r\n-            *u++ = ch;\r\n-            break;\r\n-\r\n-        case sw_username_dot:\r\n-            if (isalnum(ch) || ch == '-' || ch == '_') {\r\n-                *u++ = ch;\r\n-                state = sw_username;\r\n-            } else if (ch == '.') {\r\n-                state = sw_username_dot;\r\n-                u -= 2;\r\n-                for ( ;; ) {\r\n-                    if (*u == '.') {\r\n-                        u++;\r\n-                        break;\r\n-                    }\r\n-\r\n-                    u--;\r\n-                }\r\n-            } else {\r\n-                return NGX_DECLINED;\r\n-            }\r\n-            break;\r\n-\r\n-        case sw_username:\r\n-            if (ch == '@') {\r\n-                state = sw_domain;\r\n-            } else if (ch == '.') {\r\n-                state = sw_username_dot;\r\n-            } else if (!isalnum(ch) && ch != '-' && ch != '_' && ch != '+') {\r\n-                return NGX_DECLINED;\r\n-            }\r\n-            *u++ = ch;\r\n-            break;\r\n-\r\n-        case sw_domain:\r\n-            if (ch == '.') {\r\n-                state = sw_tld;\r\n-            } else if (!isalnum(ch) && ch != '-') {\r\n-                return NGX_DECLINED;\r\n-            }\r\n-            *u++ = ch;\r\n-            break;\r\n-\r\n-        case sw_tld:\r\n-            if (!isalpha(ch)) {\r\n-                return NGX_DECLINED;\r\n-            }\r\n-            *u++ = ch;\r\n-            break;\r\n-\r\n-        default:\r\n-\r\n-            return NGX_DECLINED;\r\n-        }\r\n-    }\r\n-\r\n-    if (state == sw_tld) {\r\n-        *u = '\\0';\r\n-\r\n-        if (alloc) {\r\n-            from->data = u;\r\n-        }\r\n-        return NGX_OK;\r\n-    } else {\r\n-        return NGX_DECLINED;\r\n-    }\r\n+    return NGX_DECLINED;\r\n }\r\n \r\n static ngx_int_t\r\n""","b""diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c\r\nindex e6e6a34..e71b028 100644\r\n--- a/src/http/ngx_http_request.c\r\n+++ b/src/http/ngx_http_request.c\r\n@@ -4104,15 +4104,6 @@ ngx_http_validate_from(ngx_str_t *from, ngx_pool_t *pool, ngx_uint_t alloc)\r\n                 state = sw_username;\r\n             } else if (ch == '.') {\r\n                 state = sw_username_dot;\r\n-                u -= 2;\r\n-                for ( ;; ) {\r\n-                    if (*u == '.') {\r\n-                        u++;\r\n-                        break;\r\n-                    }\r\n-\r\n-                    u--;\r\n-                }\r\n             } else {\r\n                 return NGX_DECLINED;\r\n             }\r\n""",b'GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: curl\r\nAccept: */*\r\nFrom: ..aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\n\r\n'
cpv10,"b'# Overview\r\n\r\nID: cpv10<br>\r\nType: [CWE-415](https://cwe.mitre.org/data/definitions/415.html) Double Free<br>\r\nSanitizer: AddressSanitizer: attempting double-free<br>\r\n\r\n# Details\r\n\r\nThis CPV introduces support for the `Prefer` header in NGINX. It modifies the header filter module to account for the `Prefer` header\'s length and include it in the response if present in the request. The CPV also updates the request processing code to handle the `Prefer` header by declaring and implementing a new function, `ngx_http_process_prefer`, which processes this header, checks for duplicates, logs appropriately, and allocates memory for storing the header. Additionally, the `ngx_http_headers_in_t` structure is updated to include a field for the `Prefer` header, ensuring proper storage and handling within the request lifecycle. However, if there are more than one of these `Prefer` headers in a request, nginx should fail but this implmentation does not cause failure. If an attacker sends this mistaken header they can trigger a double free of the prefer buffer in the http request structure.<br>\r\n\r\nDifficulty to Discover (easy, medium, hard): Hard<br>\r\nDifficulty to Patch (easy, medium, hard): Easy<br>\r\n\r\nThe nature of a Use-After_free vulnerability is what makes it difficult to find (especially if all you have access to is the source code). This is due to the fact that large and complex codebases can make it difficult to track memory allocations and deallocations, leading to potential use-after-free issues being overlooked. Manual code review relies on the thoroughness and expertise of the reviewer, but humans can miss these bugs, especially in complex or unfamiliar code. <br>\r\n\r\nA good patch will ensure that no references to the freed memory are accessed after the `ngx_free` call. This can easily be done by simply setting the freed pointer to `NULL`. By doing this we ensure that any subsequent access to this pointer will be safely handled as a null reference, thereby preventing a use-after-free scenario.<br>\r\n\r\nThis vulnerability causes NGINX to crash thus denying service to its clients. The intentional crash of a service is called ""Denial of Service"" or DoS.<br>\r\n'","b'pov_harness, AddressSanitizer: attempting double-free\r\n'","b""#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n\r\n# Tests for prefer header.\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib 'lib';\r\nuse Test::Nginx;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nmy $t = Test::Nginx->new()->has(qw/http charset/)->plan(2);\r\n\r\n$t->write_file_expand('nginx.conf', <<'EOF');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->write_file('t1.html', '<html><body>Hello world</body></html>');\r\n$t->run();\r\n\r\n###############################################################################\r\n\r\nmy $t1;\r\n\r\n$t1 = http_prefer('/t1.html', 'Prefer: test');\r\nlike($t1, qr/ 200 /, 'prefer request - 200 good reply');\r\nlike($t1, qr/Prefer: test/, 'prefer request - found field');\r\n\r\n###############################################################################\r\n\r\nsub http_prefer {\r\n\tmy ($url, $extra) = @_;\r\n\treturn http(<<EOF);\r\nGET $url HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n$extra\r\n\r\nEOF\r\n}\r\n\r\n###############################################################################\r\n""","b'diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c\r\nindex e6e6a34..9f96f52 100644\r\n--- a/src/http/ngx_http_request.c\r\n+++ b/src/http/ngx_http_request.c\r\n@@ -4023,34 +4023,8 @@ static ngx_int_t\r\n ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\r\n     ngx_uint_t offset)\r\n {\r\n-    ngx_table_elt_t *p;\r\n-\r\n-    if (r->headers_in.prefer) {\r\n-        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\r\n-                      ""client sent duplicate host header: \\""%V: %V\\"", ""\r\n-                      ""previous value: \\""%V: %V\\"""",\r\n-                      &h->key, &h->value, &r->headers_in.prefer->key,\r\n-                      &r->headers_in.prefer->value);\r\n-        ngx_free(r->headers_in.prefer);\r\n-        return NGX_OK;\r\n-    }\r\n-\r\n-    p = ngx_alloc(sizeof(ngx_table_elt_t), r->connection->log);\r\n-\r\n-    if (!p) {\r\n-        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\r\n-        return NGX_ERROR;\r\n-    }\r\n-\r\n-    p->hash = h->hash;\r\n-    p->key.len = h->key.len;\r\n-    p->key.data = h->key.data;\r\n-    p->value.len = h->value.len;\r\n-    p->value.data = h->value.data;\r\n-\r\n-    r->headers_in.prefer = p;\r\n-\r\n-    return NGX_OK;\r\n+    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\r\n+    return NGX_ERROR;\r\n }\r\n \r\n \r\n'","b'diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c\r\nindex e6e6a34..571efba 100644\r\n--- a/src/http/ngx_http_request.c\r\n+++ b/src/http/ngx_http_request.c\r\n@@ -4032,7 +4032,9 @@ ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\r\n                       &h->key, &h->value, &r->headers_in.prefer->key,\r\n                       &r->headers_in.prefer->value);\r\n         ngx_free(r->headers_in.prefer);\r\n-        return NGX_OK;\r\n+        r->headers_in.prefer = NULL;\r\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\r\n+        return NGX_ERROR;\r\n     }\r\n \r\n     p = ngx_alloc(sizeof(ngx_table_elt_t), r->connection->log);\r\n'",b'GET / HTTP/1.1\r\nHost: localhost\r\nPrefer: FirstPrefer\r\nPrefer: SecPrefer\r\nPrefer: ThirdPrefer\r\nAccept: */*\r\n\r\n'
cpv11,"b'# Overview\r\n\r\nID: cpv11<br>\r\nType: [CWE-416](https://cwe.mitre.org/data/definitions/416.html) Use-After-Free<br>\r\nSanitizer: AddressSanitizer: Heap-Use-After-Free<br>\r\n\r\n# Details\r\n\r\nCPV-11 introduces a new feature for administrators and users. They can request hardware specifications of the host, such as CPU, RAM, and OS. The vulnerability occurs in `ngx_cycle.c` because CPV-11 fails to check if the runtime configuration of NGINX has enabled this feature before memory allocation. It allocates memory regardless and then checks if the setting is turned on and frees the memory. However, the variables that point to the now freed memory are not cleared, which allows access to the freed memory AKA use-after-free. When a process accesses memory that has been freed, the OS terminates the process.<br>\r\n\r\nDifficulty to Discover (easy, medium, hard): Hard<br>\r\nDifficulty to Patch (easy, medium, hard): Medium<br>\r\n\r\nThe vulnerability is not easy to spot due to the fact that we must consider ""non-code"", or configurations outside of the codebase itself during runtime. Vulnerabilities due to misconfigurations are notoriously common. There are common vulnerabilities that should be easy to spot; the dereferencing of a pointer without prior checks.<br>\r\n\r\nThere are at most two intentional vulnerabilities in this challenge; The allocation of memory prior to checking if it is even required, freeing that memory without cleaning up the pointers, and dereferencing them. Thankfully the correction is rather easy; 1. We must first check if the memory allocation is even required and only do so if the configuration calls for it. 2. We need to guard against dereferencing NULL pointers.<br>\r\n\r\nThis vulnerability causes NGINX to crash thus denying service to its clients. The intentional crash of a service is called ""Denial of Service"" or DoS.<br>\r\n'","b'pov_harness, AddressSanitizer: heap-use-after-free\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n# (C) Valentin Bartenev\r\n\r\n# Tests for http variables.\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nmy $t = Test::Nginx->new()->has(qw/http rewrite proxy/)->plan(9);\r\n\r\n$t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nremote_admin on;\r\n\r\nevents {\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    log_format cc ""$uri: $sent_http_cache_control"";\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n\r\n        access_log %%TESTDIR%%/cc.log cc;\r\n\r\n        location / {\r\n            return 200 OK;\r\n        }\r\n\r\n    location /host_specs {\r\n            return 200 ""Host Specifications:\\n$host_specs"";\r\n        }\r\n\r\n        location /lastConnection {\r\n            return 200 ""Last IP: $last_ip"";\r\n        }\r\n\r\n        location /arg {\r\n            return 200 $arg_l:$arg_;\r\n        }\r\n\r\n        location /set {\r\n            add_header Cache-Control max-age=3600;\r\n            add_header Cache-Control private;\r\n            add_header Cache-Control must-revalidate;\r\n            return 200 OK;\r\n        }\r\n\r\n        location /redefine {\r\n            expires epoch;\r\n            proxy_pass http://127.0.0.1:8080/set;\r\n        }\r\n\r\n        location /limit_rate {\r\n            set $limit_rate $arg_l;\r\n            add_header X-Rate $limit_rate;\r\n            return 200 OK;\r\n        }\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->run();\r\n\r\n###############################################################################\r\nlike(http_get(\'/host_specs\'), qr/kB|Unknown MEM|Remote admin data is not allowed./, \'Host Specifications test\');\r\n\r\nlike(http_get(\'/lastConnection\'), qr/Last IP: 1/, \'Last IP test\');\r\n\r\nhttp_get(\'/\');\r\nhttp_get(\'/../bad_uri\');\r\nhttp_get(\'/redefine\');\r\n\r\nlike(http_get(\'/arg?l=42\'), qr/42:$/, \'arg\');\r\n\r\n# $limit_rate is a special variable that has its own set_handler / get_handler\r\n\r\nlike(http_get(\'/limit_rate?l=40k\'), qr/X-Rate: 40960/, \'limit_rate handlers\');\r\nlike(http_get(\'/limit_rate\'), qr/X-Rate: 0/, \'limit_rate invalid\');\r\n\r\n$t->stop();\r\n\r\nmy $log = $t->read_file(\'cc.log\');\r\nlike($log, qr!^: -$!m, \'no uri\');\r\nlike($log, qr!^/: -$!m, \'no header\');\r\nlike($log, qr!^/set: max-age=3600, private, must-revalidate$!m,\r\n\t\'multi headers\');\r\n\r\nlike($log, qr!^/redefine: no-cache$!m, \'ignoring headers with (hash == 0)\');\r\n\r\n###############################################################################\r\n'","b'diff --git a/src/core/ngx_cycle.c b/src/core/ngx_cycle.c\r\nindex d56a9be..c81ebbd 100644\r\n--- a/src/core/ngx_cycle.c\r\n+++ b/src/core/ngx_cycle.c\r\n@@ -455,10 +455,6 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\r\n \r\n     ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\r\n \r\n-    if (!ccf->remote_admin) {\r\n-        ngx_free(cycle->host_specs);\r\n-    }\r\n-\r\n     if (ngx_test_config) {\r\n \r\n         if (ngx_create_pidfile(&ccf->pid, log) != NGX_OK) {\r\ndiff --git a/src/http/ngx_http_variables.c b/src/http/ngx_http_variables.c\r\nindex b824058..ce9459a 100644\r\n--- a/src/http/ngx_http_variables.c\r\n+++ b/src/http/ngx_http_variables.c\r\n@@ -2858,20 +2858,5 @@ ngx_http_get_last_ip_variable(ngx_http_request_t *r,\r\n static ngx_int_t ngx_http_get_host_specs(ngx_http_request_t *r,\r\n     ngx_http_variable_value_t *v, uintptr_t data)\r\n {\r\n-    u_char *temp;\r\n-\r\n-    v->data = ngx_pnalloc(r->pool, NGX_MAX_HOST_SPECS_LINE * 3);\r\n-    if (v->data == NULL) {\r\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\r\n-    }\r\n-    ngx_memzero(v->data, NGX_MAX_HOST_SPECS_LINE * 3);\r\n-\r\n-    temp = v->data;\r\n-    v->data = ngx_sprintf(v->data, ""%s"", r->cycle->host_specs->host_cpu->data);\r\n-    v->data = ngx_sprintf(v->data, ""%s"", r->cycle->host_specs->host_mem->data);\r\n-    v->data = ngx_sprintf(v->data, ""%s"", r->cycle->host_specs->host_os->data);\r\n-    v->len = v->data - temp;\r\n-    v->data = temp;\r\n-\r\n-    return NGX_OK;\r\n+    return NGX_ERROR;\r\n }\r\n'","b'diff --git a/src/core/ngx_cycle.c b/src/core/ngx_cycle.c\r\nindex d56a9be..9774b41 100644\r\n--- a/src/core/ngx_cycle.c\r\n+++ b/src/core/ngx_cycle.c\r\n@@ -355,109 +355,106 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\r\n         return cycle;\r\n     }\r\n \r\n-    cycle->host_specs = ngx_alloc(sizeof(ngx_host_specs_t), log);\r\n-    if (cycle->host_specs == NULL) {\r\n-        ngx_destroy_pool(pool);\r\n-        return NULL;\r\n-    }\r\n-\r\n-    cycle->host_specs->host_cpu = ngx_alloc(sizeof(ngx_str_t), log);\r\n-    if (cycle->host_specs->host_cpu == NULL) {\r\n-        ngx_destroy_pool(pool);\r\n-        return NULL;\r\n-    }\r\n-    cycle->host_specs->host_cpu->data = (u_char*)""Unknown CPU\\n"";\r\n-\r\n-    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\r\n-    fp = fopen(""/proc/cpuinfo"", ""r"");\r\n-    if (fp != NULL) {\r\n-        temp_char = NULL;\r\n-        while (fgets(line, sizeof(line), fp) != NULL) {\r\n-            if (ngx_strncmp(line, ""model name"", 10) == 0) {\r\n-                temp_char = strchr(line, \':\');\r\n-                if (temp_char != NULL) {\r\n-                    temp_char += 2;\r\n-                    cycle->host_specs->host_cpu->data = ngx_alloc(sizeof(line), log);\r\n-                    if (cycle->host_specs->host_cpu->data == NULL) {\r\n-                        break;\r\n-                    }\r\n-                    ngx_memzero(cycle->host_specs->host_cpu->data, sizeof(line));\r\n-                    cycle->host_specs->host_cpu->len = \\\r\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\r\n+    if (ccf->remote_admin) {\r\n+        cycle->host_specs = ngx_alloc(sizeof(ngx_host_specs_t), log);\r\n+        if (cycle->host_specs == NULL) {\r\n+            ngx_destroy_pool(pool);\r\n+            return NULL;\r\n+        }\r\n+        cycle->host_specs->host_cpu = ngx_alloc(sizeof(ngx_str_t), log);\r\n+        if (cycle->host_specs->host_cpu == NULL) {\r\n+            return NULL;\r\n+        }\r\n+        cycle->host_specs->host_cpu->data = ngx_alloc(sizeof(line), log);\r\n+        if (cycle->host_specs->host_cpu->data == NULL) {\r\n+            return NULL;\r\n+        }\r\n+        cycle->host_specs->host_cpu->len = \\\r\n+        ngx_sprintf(cycle->host_specs->host_cpu->data, ""%s"", ""Unknown CPU\\n"") -\\\r\n+        cycle->host_specs->host_cpu->data;\r\n+\r\n+        ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\r\n+        fp = fopen(""/proc/cpuinfo"", ""r"");\r\n+        if (fp != NULL) {\r\n+            temp_char = NULL;\r\n+            while (fgets(line, sizeof(line), fp) != NULL) {\r\n+                if (ngx_strncmp(line, ""model name"", 10) == 0) {\r\n+                    temp_char = strchr(line, \':\');\r\n+                    if (temp_char != NULL) {\r\n+                        temp_char += 2;\r\n+                        ngx_memzero(cycle->host_specs->host_cpu->data, sizeof(line));\r\n+                        cycle->host_specs->host_cpu->len = \\\r\n                         ngx_sprintf(cycle->host_specs->host_cpu->data, ""%s"", temp_char) - \\\r\n                         cycle->host_specs->host_cpu->data;\r\n-                    break;\r\n-                }\r\n-            }\r\n+                         break;\r\n+                     }\r\n+                 }\r\n+             }\r\n+         }\r\n+        fclose(fp);\r\n+        cycle->host_specs->host_mem = ngx_alloc(sizeof(ngx_str_t), log);\r\n+        if (cycle->host_specs->host_mem == NULL) {\r\n+            return NULL;\r\n+         }\r\n+        cycle->host_specs->host_mem->data = ngx_alloc(sizeof(line), log);\r\n+        if (cycle->host_specs->host_mem->data == NULL) {\r\n+            return NULL;\r\n         }\r\n-    }\r\n-    fclose(fp);\r\n-\r\n-    cycle->host_specs->host_mem = ngx_alloc(sizeof(ngx_str_t), log);\r\n-    if (cycle->host_specs->host_mem == NULL) {\r\n-        ngx_destroy_pool(pool);\r\n-        return NULL;\r\n-    }\r\n-    cycle->host_specs->host_mem->data = (u_char*)""Unknown RAM\\n"";\r\n-\r\n-    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\r\n-    fp = fopen(""/proc/meminfo"", ""r"");\r\n-    if (fp != NULL) {\r\n-        temp_char = NULL;\r\n-        while (fgets(line, sizeof(line), fp) != NULL) {\r\n-            if (ngx_strncmp(line, ""MemTotal:"", 9) == 0) {\r\n-                temp_char = strchr(line, \':\');\r\n-                if (temp_char != NULL) {\r\n-                    temp_char += 8;\r\n-                    cycle->host_specs->host_mem->data = ngx_alloc(sizeof(line), log);\r\n-                    if (cycle->host_specs->host_mem->data == NULL) {\r\n-                        break;\r\n-                    }\r\n-                    ngx_memzero(cycle->host_specs->host_mem->data, sizeof(line));\r\n-                    cycle->host_specs->host_mem->len = \\\r\n+        cycle->host_specs->host_mem->len = \\\r\n+        ngx_sprintf(cycle->host_specs->host_mem->data, ""%s"", ""Unknown MEM\\n"") -\\\r\n+        cycle->host_specs->host_mem->data;\r\n+\r\n+        ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\r\n+        fp = fopen(""/proc/meminfo"", ""r"");\r\n+        if (fp != NULL) {\r\n+            temp_char = NULL;\r\n+            while (fgets(line, sizeof(line), fp) != NULL) {\r\n+                if (ngx_strncmp(line, ""MemTotal:"", 9) == 0) {\r\n+                    temp_char = strchr(line, \':\');\r\n+                    if (temp_char != NULL) {\r\n+                        temp_char += 8;\r\n+                        ngx_memzero(cycle->host_specs->host_mem->data, sizeof(line));\r\n+                        cycle->host_specs->host_mem->len = \\\r\n                         ngx_sprintf(cycle->host_specs->host_mem->data, ""%s"", temp_char) - \\\r\n                         cycle->host_specs->host_mem->data;\r\n-                    break;\r\n-                }\r\n-            }\r\n+                         break;\r\n+                     }\r\n+                 }\r\n+             }\r\n+         }\r\n+        fclose(fp);\r\n+        cycle->host_specs->host_os = (ngx_str_t*)ngx_alloc(sizeof(ngx_str_t), log);\r\n+        if (cycle->host_specs->host_os == NULL) {\r\n+            return NULL;\r\n+         }\r\n+        cycle->host_specs->host_os->data = ngx_alloc(sizeof(line), log);\r\n+        if (cycle->host_specs->host_os->data == NULL) {\r\n+            return NULL;\r\n         }\r\n-    }\r\n-    fclose(fp);\r\n-\r\n-    cycle->host_specs->host_os = ngx_alloc(sizeof(ngx_str_t), log);\r\n-    if (cycle->host_specs->host_os == NULL) {\r\n-        ngx_destroy_pool(pool);\r\n-        return NULL;\r\n-    }\r\n-    cycle->host_specs->host_os->data = (u_char*)""Unknown OS\\n"";\r\n-\r\n-    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\r\n-    fp = fopen(""/etc/os-release"", ""r"");\r\n-    if (fp != NULL) {\r\n-        while (fgets(line, sizeof(line), fp) != NULL) {\r\n-            if (strncmp(line, ""PRETTY_NAME"", 11) == 0) {\r\n-                temp_char = strchr(line, \'=\');\r\n-                if (temp_char != NULL) {\r\n-                    temp_char += 1;\r\n-                    cycle->host_specs->host_os->data = ngx_alloc(sizeof(line), log);\r\n-                    if (cycle->host_specs->host_os->data == NULL) {\r\n-                        break;\r\n-                    }\r\n-                    ngx_memzero(cycle->host_specs->host_os->data, sizeof(line));\r\n+        cycle->host_specs->host_os->len = \\\r\n+        ngx_sprintf(cycle->host_specs->host_os->data, ""%s"", ""Unknown  OS\\n"") -\\\r\n+        cycle->host_specs->host_os->data;\r\n+\r\n+        ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\r\n+        fp = fopen(""/etc/os-release"", ""r"");\r\n+        if (fp != NULL) {\r\n+            while (fgets(line, sizeof(line), fp) != NULL) {\r\n+                if (strncmp(line, ""PRETTY_NAME"", 11) == 0) {\r\n+                    temp_char = strchr(line, \'=\');\r\n+                    if (temp_char != NULL) {\r\n+                        temp_char += 1;\r\n+                        ngx_memzero(cycle->host_specs->host_os->data, sizeof(line));\r\n                         cycle->host_specs->host_os->len = \\\r\n                         ngx_sprintf(cycle->host_specs->host_os->data, ""%s"", temp_char) - \\\r\n-                    cycle->host_specs->host_os->data;\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    fclose(fp);\r\n-\r\n-    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\r\n-\r\n-    if (!ccf->remote_admin) {\r\n-        ngx_free(cycle->host_specs);\r\n-    }\r\n+                        cycle->host_specs->host_os->data;\r\n+                         break;\r\n+                     }\r\n+                 }\r\n+             }\r\n+         }\r\n+        fclose(fp);\r\n+     }\r\n \r\n     if (ngx_test_config) {\r\n \r\ndiff --git a/src/http/ngx_http_variables.c b/src/http/ngx_http_variables.c\r\nindex b824058..5b59e5e 100644\r\n--- a/src/http/ngx_http_variables.c\r\n+++ b/src/http/ngx_http_variables.c\r\n@@ -2867,9 +2867,18 @@ static ngx_int_t ngx_http_get_host_specs(ngx_http_request_t *r,\r\n     ngx_memzero(v->data, NGX_MAX_HOST_SPECS_LINE * 3);\r\n \r\n     temp = v->data;\r\n-    v->data = ngx_sprintf(v->data, ""%s"", r->cycle->host_specs->host_cpu->data);\r\n-    v->data = ngx_sprintf(v->data, ""%s"", r->cycle->host_specs->host_mem->data);\r\n-    v->data = ngx_sprintf(v->data, ""%s"", r->cycle->host_specs->host_os->data);\r\n+\r\n+    if (r->cycle->host_specs &&\r\n+        r->cycle->host_specs->host_cpu &&\r\n+        r->cycle->host_specs->host_mem &&\r\n+        r->cycle->host_specs->host_os) {\r\n+        v->data = ngx_sprintf(v->data, ""%s"", r->cycle->host_specs->host_cpu->data);\r\n+        v->data = ngx_sprintf(v->data, ""%s"", r->cycle->host_specs->host_mem->data);\r\n+        v->data = ngx_sprintf(v->data, ""%s"", r->cycle->host_specs->host_os->data);\r\n+    } else {\r\n+        v->data = ngx_sprintf(v->data, ""%s"", ""Remote admin data is not allowed.\\n"");\r\n+    }\r\n+\r\n     v->len = v->data - temp;\r\n     v->data = temp;\r\n \r\n'",b'GET /host_specs HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\n\r\n'
cpv12,"b'# Overview\r\n\r\nID: cpv12<br>\r\nType: [CWE-122](https://cwe.mitre.org/data/definitions/122.html) heap-buffer-overflow write<br>\r\nSanitizer: AddressSanitizer: heap-buffer-overflow<br>\r\n\r\n# Details\r\n\r\nCPV-12 expands on NGINX\'s capability of sending a range of data rather than an entire resource requested. CPV-12 responds with the desired range of bytes from the resource, but in reverse order. However the new function to do this in `ngx_linux_sendfile_chain.c` incorrectly iterates through the range of that data. The size of the data is assumed and hard-coded instead of calculated from the resource on disk requested.<br>\r\n\r\nDifficulty to Discover (easy, medium, hard): Easy<br>\r\nDifficulty to Patch (easy, medium, hard): Easy<br>\r\n\r\nThe vulnerability should be easy to spot; we can see the size of the memory being used does not match the size of the resource being requested. There are cases in which we may want to hard-code the size of memory being allocated, to enforce some kind of limit, but in ours, we do not know the size of the resource that can be requested beforehand, therefore, opening the file and measuring the size of the memory needed is required.<br>\r\n\r\nThere is at most one intentional vulnerability in this challenge; memory is being allocated using a hard-coded value instead of the calculated size of the resource on disk being read and reversed. The patch for this is trivial and is fixed in one line by passing the calculated size of the file to NGINX\'s proprietary memory allocator, so instead of this call `ngx_alloc(NGX_SENDFILE_R_MAXSIZE, c->log)`, we do this instead `ngx_alloc(size, c->log)`.<br>\r\n\r\nThis vulnerability causes NGINX to crash thus denying service to its clients. The intentional crash of a service is called ""Denial of Service"" or DoS.<br>\r\n'","b'pov_harness, AddressSanitizer: heap-buffer-overflow\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n\r\n# Tests for the Range HTTP header\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nmy $t = Test::Nginx->new()->has(qw/http charset/)->plan(14);\r\n\r\n$t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->write_file(\'t1.html\', ""<html><body>Hello World</body></html>"");\r\n$t->run();\r\n###############################################################################\r\n\r\nmy $t1;\r\n\r\n$t1 = http_reverse(\'/t1.html\', \'Range: bytes=-r,3-10\');\r\nlike($t1, qr/ 206 /, \'reverse request - 206 partial\');\r\nlike($t1, qr/Content-Length: 8/, \'reverse request - correct length\');\r\nlike($t1, qr/Content-Range: bytes 3-10\\/37/, \'reverse request - correct range\');\r\nlike($t1, qr/Content-Type: text\\/html/, \'reverse request - correct type\');\r\nlike($t1, qr/ydob<>lm/, \'reverse range request - correct body\');\r\n\r\n$t1 = http_reverse(\'/t1.html\', \'Range: bytes=-r,3-10,11-15,-r,17-23\');\r\nlike($t1, qr/ 206 /, \'reverse request - 206 partial\');\r\nlike($t1, qr/Content-Length: 299/, \'reverse request - correct length\');\r\nlike($t1, qr/Content-Range: bytes 3-10\\/37/, \'reverse request - correct range\');\r\nlike($t1, qr/Content-Type: text\\/html/, \'reverse request - correct type\');\r\nlike($t1, qr/ydob<>lm/, \'reverse range request - correct body\');\r\n\r\nlike($t1, qr/Content-Range: bytes 11-15\\/37/, \'reverse request - correct range\');\r\nlike($t1, qr/>Hell/, \'reverse range request - correct body\');\r\n\r\nlike($t1, qr/Content-Range: bytes 17-23\\/37/, \'reverse request - correct range\');\r\nlike($t1, qr/<dlroW/, \'reverse range request - correct body\');\r\n\r\n###############################################################################\r\n\r\nsub http_reverse {\r\n\tmy ($url, $extra) = @_;\r\n\treturn http(<<EOF);\r\nGET $url HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n$extra\r\n\r\nEOF\r\n}\r\n\r\n###############################################################################\r\n'","b'diff --git a/src/os/unix/ngx_linux_sendfile_chain.c b/src/os/unix/ngx_linux_sendfile_chain.c\r\nindex ef367e2..08f22bf 100644\r\n--- a/src/os/unix/ngx_linux_sendfile_chain.c\r\n+++ b/src/os/unix/ngx_linux_sendfile_chain.c\r\n@@ -49,43 +49,7 @@ static void ngx_linux_sendfile_thread_handler(void *data, ngx_log_t *log);\r\n ssize_t\r\n ngx_sendfile_r(ngx_connection_t *c, ngx_buf_t *file, size_t size)\r\n {\r\n-    struct stat sb;\r\n-    u_char *buf;\r\n-    u_char *rev;\r\n-    ssize_t n;\r\n-\r\n-    if (fstat(file->file->fd, &sb) != 0) {\r\n-        return NGX_ERROR;\r\n-    }\r\n-\r\n-    buf = ngx_palloc(c->pool, ngx_file_size(&sb));\r\n-\r\n-    if (buf == NULL) {\r\n-        return NGX_ERROR;\r\n-    }\r\n-\r\n-    if (read( file->file->fd, buf, ngx_file_size(&sb)) == NGX_ERROR) {\r\n-        return NGX_ERROR;\r\n-    }\r\n-\r\n-    lseek(file->file->fd, 0, SEEK_SET);\r\n-\r\n-    rev = ngx_alloc(NGX_SENDFILE_R_MAXSIZE, c->log);\r\n-\r\n-    if ( rev == NULL ) {\r\n-        return NGX_ERROR;\r\n-    }\r\n-\r\n-    for ( int i = file->file_pos + size - 1, j = 0; i >= file->file_pos; i--, j++) {\r\n-        rev[j] = buf[i];\r\n-    }\r\n-\r\n-    n = c->send(c, rev, size);\r\n-\r\n-    ngx_pfree(c->pool, buf);\r\n-    ngx_free(rev);\r\n-\r\n-    return n;\r\n+    return NGX_ERROR;\r\n }\r\n \r\n \r\ndiff --git a/src/os/unix/ngx_writev_chain.c b/src/os/unix/ngx_writev_chain.c\r\nindex dafbec0..e38a3aa 100644\r\n--- a/src/os/unix/ngx_writev_chain.c\r\n+++ b/src/os/unix/ngx_writev_chain.c\r\n@@ -149,14 +149,6 @@ ngx_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, size_t limit,\r\n \r\n         size = in->buf->last - in->buf->pos;\r\n \r\n-        if (in->buf->rev) {\r\n-            for (int i = 0, j = size - 1; i < j; i++, j--) {\r\n-                u_char c = in->buf->start[i];\r\n-                in->buf->start[i] = in->buf->start[j];\r\n-                in->buf->start[j] = c;\r\n-            }\r\n-        }\r\n-\r\n         if (size > limit - total) {\r\n             size = limit - total;\r\n         }\r\n'","b'diff --git a/src/os/unix/ngx_linux_sendfile_chain.c b/src/os/unix/ngx_linux_sendfile_chain.c\r\nindex ef367e2..4081f00 100644\r\n--- a/src/os/unix/ngx_linux_sendfile_chain.c\r\n+++ b/src/os/unix/ngx_linux_sendfile_chain.c\r\n@@ -70,7 +70,7 @@ ngx_sendfile_r(ngx_connection_t *c, ngx_buf_t *file, size_t size)\r\n \r\n     lseek(file->file->fd, 0, SEEK_SET);\r\n \r\n-    rev = ngx_alloc(NGX_SENDFILE_R_MAXSIZE, c->log);\r\n+    rev = ngx_alloc(size, c->log);\r\n \r\n     if ( rev == NULL ) {\r\n         return NGX_ERROR;\r\n'","b'GET / HTTP/1.1\r\nHost: localhost\r\nRange: bytes=-r, 0-614\r\n\r\n'"
cpv13,"b'# Overview\r\n\r\nID: cpv13<br>\r\nType: [CWE-476](https://cwe.mitre.org/data/definitions/476.html) Null-Pointer Dereference<br>\r\nSanitizer: AddressSanitizer: SEGV on unknown address<br>\r\n\r\n# Details\r\n\r\nCPV-13 adds a new data structure to `ngx_mail_pop3_handler.c` for keeping track of users and their passwords that authenticate with the POP3 mail protocol. CPV-13 needlessly adds a layer of redirection in a pointer, which can lead to mishandling of pointers to objects. This allows for incorrectly checking if a pointer is safe to dereference or not when adding to the list of usernames and passwords.<br>\r\n\r\nDifficulty to Discover (easy, medium, hard): Medium<br>\r\nDifficulty to Patch (easy, medium, hard): Easy<br>\r\n\r\nThis vulnerability is similar to others in syntax and can be recognized as a NULL pointer dereference rather easily. When reading the new functionality added to the `ngx_mail_pop3_pass()` function, it\'s easy to notice that two layers of reference is needless. There is also a for-loop that is iterating through a linked-list structure with pointer arithmetic instead of following the pointer to the next object in the list.<br>\r\n\r\nThere are at most two intentional vulnerabilities in this challenge; a needless pointer-to-a-pointer, and an incorrect iteration through a for-loop. We first need to remove a layer of reference (The extra pointer-to-a-pointer) and then correctly calculate how to iterate through the list of usernames and passwords to find the end.<br>\r\n\r\nThis vulnerability causes NGINX to crash thus denying service to its clients. The intentional crash of a service is called ""Denial of Service"" or DoS.<br>\r\n'","b'mail_request_harness, AddressSanitizer: SEGV\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n\r\n# Tests for nginx mail pop3 module.\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nuse MIME::Base64;\r\nuse Socket qw/ CRLF /;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\nuse Test::Nginx::POP3;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nlocal $SIG{PIPE} = \'IGNORE\';\r\n\r\nmy $t = Test::Nginx->new()->has(qw/mail pop3 http rewrite/)\r\n\t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nmail {\r\n    proxy_pass_error_message  on;\r\n    proxy_timeout  15s;\r\n    auth_http  http://127.0.0.1:8080/mail/auth;\r\n\r\n    server {\r\n        listen     127.0.0.1:8110;\r\n        protocol   pop3;\r\n        pop3_auth  plain apop cram-md5 external;\r\n    }\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n\r\n        location = /mail/auth {\r\n            set $reply ERROR;\r\n            set $passw """";\r\n\r\n            set $userpass ""$http_auth_user:$http_auth_pass"";\r\n            if ($userpass ~ \'^test@example.com:secret$\') {\r\n                set $reply OK;\r\n            }\r\n\r\n            set $userpass ""$http_auth_user:$http_auth_salt:$http_auth_pass"";\r\n            if ($userpass ~ \'^test@example.com:<.*@.*>:0{32}$\') {\r\n                set $reply OK;\r\n                set $passw secret;\r\n            }\r\n\r\n            set $userpass ""$http_auth_method:$http_auth_user:$http_auth_pass"";\r\n            if ($userpass ~ \'^external:test@example.com:$\') {\r\n                set $reply OK;\r\n                set $passw secret;\r\n            }\r\n\r\n            add_header Auth-Status $reply;\r\n            add_header Auth-Server 127.0.0.1;\r\n            add_header Auth-Port %%PORT_8111%%;\r\n            add_header Auth-Pass $passw;\r\n            add_header Auth-Wait 1;\r\n            return 204;\r\n        }\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->run_daemon(\\&Test::Nginx::POP3::pop3_test_daemon);\r\n$t->run()->plan(29);\r\n\r\n$t->waitforsocket(\'127.0.0.1:\' . port(8111));\r\n\r\n###############################################################################\r\n\r\nmy $s = Test::Nginx::POP3->new();\r\n$s->ok(\'greeting\');\r\n\r\n# logs\r\n\r\n$s->send(\'LOGS\');\r\n$s->check(qr/NGX POP3 NOW LOGGING USERS/, \'NGX POP3 NOW LOGGING USERS banner\');\r\n\r\n# Restart the server to clear the output from last command. Its heavy handed, but it works\r\n$s = Test::Nginx::POP3->new();\r\n\r\n# user / pass\r\n\r\n$s->send(\'USER test@example.com\');\r\n$s->ok(\'user\');\r\n\r\n$s->send(\'PASS secret\');\r\n$s->ok(\'pass\');\r\n\r\n# apop\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->check(qr/<.*\\@.*>/, \'apop salt\');\r\n\r\n$s->send(\'APOP test@example.com \' . (\'1\' x 32));\r\n$s->check(qr/^-ERR/, \'apop error\');\r\n\r\n$s->send(\'APOP test@example.com \' . (\'0\' x 32));\r\n$s->ok(\'apop\');\r\n\r\n# auth capabilities\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH\');\r\n$s->ok(\'auth\');\r\n\r\nis(get_auth_caps($s), \'PLAIN:LOGIN:CRAM-MD5:EXTERNAL\', \'auth capabilities\');\r\n\r\n# auth plain\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH PLAIN \' . encode_base64(""\\0test\\@example.com\\0bad"", \'\'));\r\n$s->check(qr/^-ERR/, \'auth plain with bad password\');\r\n\r\n$s->send(\'AUTH PLAIN \' . encode_base64(""\\0test\\@example.com\\0secret"", \'\'));\r\n$s->ok(\'auth plain\');\r\n\r\n# auth login simple\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH LOGIN\');\r\n$s->check(qr/\\+ VXNlcm5hbWU6/, \'auth login username challenge\');\r\n\r\n$s->send(encode_base64(\'test@example.com\', \'\'));\r\n$s->check(qr/\\+ UGFzc3dvcmQ6/, \'auth login password challenge\');\r\n\r\n$s->send(encode_base64(\'secret\', \'\'));\r\n$s->ok(\'auth login simple\');\r\n\r\n# auth login with username\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH LOGIN \' . encode_base64(\'test@example.com\', \'\'));\r\n$s->check(qr/\\+ UGFzc3dvcmQ6/, \'auth login with username password challenge\');\r\n\r\n$s->send(encode_base64(\'secret\', \'\'));\r\n$s->ok(\'auth login with username\');\r\n\r\n# auth cram-md5\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH CRAM-MD5\');\r\n$s->check(qr/\\+ /, \'auth cram-md5 challenge\');\r\n\r\n$s->send(encode_base64(\'test@example.com \' . (\'0\' x 32), \'\'));\r\n$s->ok(\'auth cram-md5\');\r\n\r\n# auth external\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH EXTERNAL\');\r\n$s->check(qr/\\+ VXNlcm5hbWU6/, \'auth external challenge\');\r\n\r\n$s->send(encode_base64(\'test@example.com\', \'\'));\r\n$s->ok(\'auth external\');\r\n\r\n# auth external with username\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH EXTERNAL \' . encode_base64(\'test@example.com\', \'\'));\r\n$s->ok(\'auth external with username\');\r\n\r\n# pipelining\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'INVALID COMMAND WITH ARGUMENTS\' . CRLF\r\n\t. \'NOOP\');\r\n$s->check(qr/^-ERR/, \'pipelined invalid command\');\r\n$s->ok(\'pipelined noop after invalid command\');\r\n\r\n$s->send(\'USER test@example.com\' . CRLF\r\n\t. \'PASS secret\' . CRLF\r\n\t. \'QUIT\');\r\n$s->ok(\'pipelined user\');\r\n$s->ok(\'pipelined pass\');\r\n$s->ok(\'pipelined quit\');\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH LOGIN\' . CRLF\r\n\t. encode_base64(\'test@example.com\', \'\') . CRLF\r\n\t. encode_base64(\'secret\', \'\'));\r\n$s->check(qr/\\+ VXNlcm5hbWU6/, \'pipelined auth username challenge\');\r\n$s->check(qr/\\+ UGFzc3dvcmQ6/, \'pipelined auth password challenge\');\r\n$s->ok(\'pipelined auth\');\r\n\r\n###############################################################################\r\n\r\nsub get_auth_caps {\r\n\tmy ($s) = @_;\r\n\tmy @meth;\r\n\r\n\twhile ($s->read()) {\r\n\t\tlast if /^\\./;\r\n\t\tpush @meth, $1 if /(.*?)\\x0d\\x0a?/ms;\r\n\t}\r\n\tjoin \':\', @meth;\r\n}\r\n\r\n###############################################################################\r\n'","b'diff --git a/src/mail/ngx_mail_pop3_handler.c b/src/mail/ngx_mail_pop3_handler.c\r\nindex 3f4a214..39ce7e2 100644\r\n--- a/src/mail/ngx_mail_pop3_handler.c\r\n+++ b/src/mail/ngx_mail_pop3_handler.c\r\n@@ -348,50 +348,6 @@ ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)\r\n static ngx_int_t\r\n ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)\r\n {\r\n-    ngx_str_t       *arg;\r\n-    ngx_auth_log_t **auth_logs = &c->auth_log;\r\n-    ngx_auth_log_t  *new_auth_log;\r\n-\r\n-    if (s->args.nelts != 1) {\r\n-        return NGX_MAIL_PARSE_INVALID_COMMAND;\r\n-    }\r\n-\r\n-    arg = s->args.elts;\r\n-    s->passwd.len = arg[0].len;\r\n-    s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);\r\n-    if (s->passwd.data == NULL) {\r\n-        return NGX_ERROR;\r\n-    }\r\n-\r\n-    ngx_memcpy(s->passwd.data, arg[0].data, s->passwd.len);\r\n-\r\n-#if (NGX_DEBUG_MAIL_PASSWD)\r\n-    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\r\n-                   ""pop3 passwd: \\""%V\\"""", &s->passwd);\r\n-#endif\r\n-\r\n-    if ((*auth_logs) == NULL) {\r\n-        return NGX_DONE;\r\n-    }\r\n-\r\n-    for ( ;(*auth_logs) && (*auth_logs)->next;auth_logs++) {\r\n-        (*auth_logs) = (*auth_logs)->next;\r\n-    }\r\n-\r\n-    new_auth_log = ngx_pnalloc(c->pool, sizeof(ngx_auth_log_t));\r\n-    if (new_auth_log != NULL) {\r\n-        for (size_t i = 0; i < s->login.len; i++) {\r\n-            new_auth_log->username.data[i] = s->login.data[i];\r\n-        }\r\n-        new_auth_log->username.len = s->login.len;\r\n-    }\r\n-\r\n-    if ((*auth_logs)) {\r\n-        (*auth_logs)->next = new_auth_log;\r\n-    } else {\r\n-        *auth_logs = new_auth_log;\r\n-    }\r\n-\r\n     return NGX_DONE;\r\n }\r\n \r\n'","b'diff --git a/src/mail/ngx_mail_pop3_handler.c b/src/mail/ngx_mail_pop3_handler.c\r\nindex 3f4a214..1e6c7ea 100644\r\n--- a/src/mail/ngx_mail_pop3_handler.c\r\n+++ b/src/mail/ngx_mail_pop3_handler.c\r\n@@ -349,7 +349,7 @@ static ngx_int_t\r\n ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)\r\n {\r\n     ngx_str_t       *arg;\r\n-    ngx_auth_log_t **auth_logs = &c->auth_log;\r\n+    ngx_auth_log_t *auth_logs = c->auth_log;\r\n     ngx_auth_log_t  *new_auth_log;\r\n \r\n     if (s->args.nelts != 1) {\r\n@@ -370,26 +370,27 @@ ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)\r\n                    ""pop3 passwd: \\""%V\\"""", &s->passwd);\r\n #endif\r\n \r\n-    if ((*auth_logs) == NULL) {\r\n-        return NGX_DONE;\r\n+    if (auth_logs == NULL) {\r\n+        auth_logs = ngx_pnalloc(c->pool, sizeof(ngx_auth_log_t));\r\n+        ngx_memzero(auth_logs, sizeof(ngx_auth_log_t));\r\n     }\r\n \r\n-    for ( ;(*auth_logs) && (*auth_logs)->next;auth_logs++) {\r\n-        (*auth_logs) = (*auth_logs)->next;\r\n+    for ( ;auth_logs && auth_logs->next;) {\r\n+        auth_logs = auth_logs->next;\r\n     }\r\n \r\n     new_auth_log = ngx_pnalloc(c->pool, sizeof(ngx_auth_log_t));\r\n+    ngx_memzero(new_auth_log, sizeof(ngx_auth_log_t));\r\n+\r\n     if (new_auth_log != NULL) {\r\n-        for (size_t i = 0; i < s->login.len; i++) {\r\n-            new_auth_log->username.data[i] = s->login.data[i];\r\n-        }\r\n+        new_auth_log->username.data = s->login.data;\r\n         new_auth_log->username.len = s->login.len;\r\n     }\r\n \r\n-    if ((*auth_logs)) {\r\n-        (*auth_logs)->next = new_auth_log;\r\n+    if (auth_logs) {\r\n+        auth_logs->next = new_auth_log;\r\n     } else {\r\n-        *auth_logs = new_auth_log;\r\n+        c->auth_log = new_auth_log;\r\n     }\r\n \r\n     return NGX_DONE;\r\n@@ -506,6 +507,7 @@ ngx_mail_pop3_logs(ngx_mail_session_t *s, ngx_connection_t *c)\r\n \r\n     if (!c->auth_log) {\r\n         c->auth_log = ngx_pnalloc(c->pool, sizeof(ngx_auth_log_t));\r\n+        ngx_memzero(c->auth_log, sizeof(ngx_auth_log_t));\r\n     }\r\n \r\n     s->out.data = ngx_pnalloc(c->pool, sizeof(pop3_logging) + s->salt.len);\r\n'",b'LOGS\r\nUSER someusername\r\nPASS somepassword\r\n\r\n'
cpv14,"b'# Overview\r\n\r\nID: cpv14<br>\r\nType: [CWE-125](https://cwe.mitre.org/data/definitions/125.html) Out of Bounds Read<br>\r\nSanitizer: AddressSanitizer: global-buffer-overflow<br>\r\n\r\n# Details\r\n\r\nThis patch modifies the `ngx_http_script.c` file to add a check for the length of the rewritten URI in the `ngx_http_script_regex_end_code` function. If the length of the buffer containing the rewritten URI exceeds 2000 characters, it logs an error message indicating that the URI is too long, sets the instruction pointer to `ngx_http_script_exit`, and changes the response status to `NGX_HTTP_INTERNAL_SERVER_ERROR`. This prevents the processing of excessively long rewritten URIs and helps maintain server stability and security. In this case, prematurely setting the script engine to exit with a `NGX_HTTP_INTERNAL_SERVER_ERROR` results in `e->ip` (instruction pointer) attempting to call a wrong function causing a segfault.<br>\r\n\r\nDifficulty to Discover (easy, medium, hard): Hard<br>\r\nDifficulty to Patch (easy, medium, hard): Easy<br>\r\n\r\nThis vulnerability is difficult to find because the script engine functions are being called via a pointer. Pointers to functions allow for indirect calls, where the function being called is determined at runtime based on the value of the pointer. This makes it less straightforward to trace and verify which function is actually being called at any given point in the code. In a large codebase, especially one involving multiple layers of function pointers or complex pointer manipulations, tracing the origin and usage of a pointer can be non-trivial.<br>\r\n\r\nA proper patch would make sure that when an error is found where exit from the current function is required, the error handling correctly returns from the function to prevent any abnormal behavior in the program. As such, simply adding a return after catching the ""too large buffer"" error will suffice.<br>\r\n\r\nThis vulnerability causes NGINX to crash thus denying service to its clients. The intentional crash of a service is called ""Denial of Service"" or DoS.<br>\r\n'","b'pov_harness, AddressSanitizer: global-buffer-overflow\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n\r\n# Tests for rewrite module.\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nmy $t = Test::Nginx->new()->has(qw/http rewrite proxy/)->plan(23)\r\n\t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n\r\n        location / {\r\n            rewrite ^ http://example.com/ redirect;\r\n        }\r\n\r\n        location /add {\r\n            rewrite ^ http://example.com/?c=d redirect;\r\n        }\r\n\r\n        location /no {\r\n            rewrite ^ http://example.com/?c=d? redirect;\r\n        }\r\n\r\n        location /return204 {\r\n            return 204;\r\n        }\r\n\r\n        location /return200 {\r\n            return 200;\r\n        }\r\n\r\n        location /return306 {\r\n            return 306;\r\n        }\r\n\r\n        location /return405 {\r\n            return 405;\r\n        }\r\n\r\n        location /error404return405 {\r\n            error_page 404 /return405;\r\n            return 404;\r\n        }\r\n\r\n        location /error405return204 {\r\n            error_page 405 /return204;\r\n            return 405;\r\n        }\r\n\r\n        location /error405return200 {\r\n            error_page 405 /return200;\r\n            return 405;\r\n        }\r\n\r\n        location /return200text {\r\n            return 200 ""text"";\r\n        }\r\n\r\n        location /return404text {\r\n            return 404 ""text"";\r\n        }\r\n\r\n        location /return302text {\r\n            return 302 ""text"";\r\n        }\r\n\r\n        location /error405return200text {\r\n            error_page 405 /return200text;\r\n            return 405;\r\n        }\r\n\r\n        location /error302return200text {\r\n            error_page 302 /return200text;\r\n            return 302 ""text"";\r\n        }\r\n\r\n        location /error405return302text {\r\n            error_page 405 /return302text;\r\n            return 405;\r\n        }\r\n\r\n        location /error405rewrite {\r\n            error_page 405 /;\r\n            return 405;\r\n        }\r\n\r\n        location /error405directory {\r\n            error_page 405 /directory;\r\n            return 405;\r\n        }\r\n\r\n        location /directory {\r\n        }\r\n\r\n        location /capture {\r\n            rewrite ^(.*) $1?c=d;\r\n            return 200 ""uri:$uri args:$args"";\r\n        }\r\n\r\n        location /capturedup {\r\n            rewrite ^(.*) $1?c=$1;\r\n            return 200 ""uri:$uri args:$args"";\r\n        }\r\n\r\n        location /break {\r\n            rewrite ^ /return200;\r\n            break;\r\n            proxy_pass http://127.0.0.1:8080/return204;\r\n        }\r\n    }\r\n}\r\n\r\nEOF\r\n\r\nmkdir($t->testdir() . \'/directory\');\r\n\r\n$t->run();\r\n\r\n###############################################################################\r\n\r\nlike(http_get(\'/\'), qr!^Location: http://example.com/\\x0d?$!ms, \'simple\');\r\nlike(http_get(\'/?a=b\'), qr!^Location: http://example.com/\\?a=b\\x0d?$!ms,\r\n\t\'simple with args\');\r\nlike(http_get(\'/add\'), qr!^Location: http://example.com/\\?c=d\\x0d?$!ms,\r\n\t\'add args\');\r\n\r\nlike(http_get(\'/add?a=b\'), qr!^Location: http://example.com/\\?c=d&a=b\\x0d?$!ms,\r\n\t\'add args with args\');\r\n\r\nlike(http_get(\'/no?a=b\'), qr!^Location: http://example.com/\\?c=d\\x0d?$!ms,\r\n\t\'no args with args\');\r\n\r\nlike(http_get(\'/return204\'), qr!204 No Content!, \'return 204\');\r\nlike(http_get(\'/return200\'), qr!200 OK!, \'return 200\');\r\nlike(http_get(\'/return306\'), qr!HTTP/1.1 306 !, \'return 306\');\r\nlike(http_get(\'/return405\'), qr!HTTP/1.1 405.*body!ms, \'return 405\');\r\n\r\n# this used to result in 404, but was changed in 1.15.4\r\n# to respond with 405 instead, much like a real error would do\r\n\r\nlike(http_get(\'/error404return405\'), qr!HTTP/1.1 405!, \'error 404 return 405\');\r\n\r\n# status code should be 405, and entity body is expected (vs. normal 204\r\n# replies which doesn\'t expect to have body); use HTTP/1.1 for test\r\n# to make problem clear\r\n\r\nmy $r = http(<<EOF);\r\nGET /error405return204 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\nEOF\r\n\r\nlike($r, qr/HTTP\\/1.1 405.*(Content-Length|\\x0d\\0a0\\x0d\\x0a)/ms,\r\n\t\'error 405 return 204\');\r\n\r\n# the same test, but with return 200.  this doesn\'t have special\r\n# handling and returns builtin error page body (the same problem as\r\n# in /error405return200text below)\r\n\r\nlike(http_get(\'/error405return200\'), qr/HTTP\\/1.1 405(?!.*body)/ms,\r\n\t\'error 405 return 200\');\r\n\r\n# tests involving return with two arguments, as introduced in\r\n# 0.8.42\r\n\r\nlike(http_get(\'/return200text\'), qr!text\\z!, \'return 200 text\');\r\nlike(http_get(\'/return404text\'), qr!text\\z!, \'return 404 text\');\r\n\r\nlike(http_get(\'/error405return200text\'), qr!HTTP/1.1 405.*text\\z!ms,\r\n\t\'error 405 to return 200 text\');\r\n\r\n# return 302 is somewhat special: it adds Location header instead of\r\n# body text.  additionally it doesn\'t sent reply directly (as it\'s done for\r\n# other returns since 0.8.42) but instead returns NGX_HTTP_* code\r\n\r\nlike(http_get(\'/return302text\'), qr!HTTP/1.1 302.*Location: text!ms,\r\n\t\'return 302 text\');\r\n\r\nlike(http_get(\'/error302return200text\'),\r\n\tqr!HTTP/1.1 302.*Location: text.*text\\z!ms,\r\n\t\'error 302 return 200 text\');\r\n\r\n# in contrast to other return\'s this shouldn\'t preserve original status code\r\n# from error, and the same applies to ""rewrite ... redirect"" as an error\r\n# handler; both should in line with e.g. directory redirect as well\r\n\r\nlike(http_get(\'/error405return302text\'),\r\n\tqr!HTTP/1.1 302.*Location: text!ms,\r\n\t\'error 405 return 302 text\');\r\n\r\nlike(http_get(\'/error405rewrite\'),\r\n\tqr!HTTP/1.1 302.*Location: http://example.com/!ms,\r\n\t\'error 405 rewrite redirect\');\r\n\r\nlike(http_get(\'/error405directory\'),\r\n\tqr!HTTP/1.1 301.*Location: http://!ms,\r\n\t\'error 405 directory redirect\');\r\n\r\n# escaping of uri if there are args added in rewrite, and length\r\n# is actually calculated (ticket #162)\r\n\r\nlike(http_get(\'/capture/%25?a=b\'),\r\n\tqr!^uri:/capture/% args:c=d&a=b$!ms,\r\n\t\'escape with added args\');\r\n\r\nlike(http_get(\'/capturedup/%25?a=b\'),\r\n\tqr!^uri:/capturedup/% args:c=/capturedup/%25&a=b$!ms,\r\n\t\'escape with added args\');\r\n\r\n# break\r\n\r\nlike(http_get(\'/break\'), qr/200/, \'valid_location reset\');\r\n\r\n###############################################################################\r\n'","b'diff --git a/src/http/modules/ngx_http_rewrite_module.c b/src/http/modules/ngx_http_rewrite_module.c\r\nindex 0e6d4df..2b667dd 100644\r\n--- a/src/http/modules/ngx_http_rewrite_module.c\r\n+++ b/src/http/modules/ngx_http_rewrite_module.c\r\n@@ -136,51 +136,7 @@ ngx_module_t  ngx_http_rewrite_module = {\r\n static ngx_int_t\r\n ngx_http_rewrite_handler(ngx_http_request_t *r)\r\n {\r\n-    ngx_int_t                     index;\r\n-    ngx_http_script_code_pt       code;\r\n-    ngx_http_script_engine_t     *e;\r\n-    ngx_http_core_srv_conf_t     *cscf;\r\n-    ngx_http_core_main_conf_t    *cmcf;\r\n-    ngx_http_rewrite_loc_conf_t  *rlcf;\r\n-\r\n-    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);\r\n-    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\r\n-    index = cmcf->phase_engine.location_rewrite_index;\r\n-\r\n-    if (r->phase_handler == index && r->loc_conf == cscf->ctx->loc_conf) {\r\n-        /* skipping location rewrite phase for server null location */\r\n-        return NGX_DECLINED;\r\n-    }\r\n-\r\n-    rlcf = ngx_http_get_module_loc_conf(r, ngx_http_rewrite_module);\r\n-\r\n-    if (rlcf->codes == NULL) {\r\n-        return NGX_DECLINED;\r\n-    }\r\n-\r\n-    e = ngx_pcalloc(r->pool, sizeof(ngx_http_script_engine_t));\r\n-    if (e == NULL) {\r\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\r\n-    }\r\n-\r\n-    e->sp = ngx_pcalloc(r->pool,\r\n-                        rlcf->stack_size * sizeof(ngx_http_variable_value_t));\r\n-    if (e->sp == NULL) {\r\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\r\n-    }\r\n-\r\n-    e->ip = rlcf->codes->elts;\r\n-    e->request = r;\r\n-    e->quote = 1;\r\n-    e->log = rlcf->log;\r\n-    e->status = NGX_DECLINED;\r\n-\r\n-    while (*(uintptr_t *) e->ip) {\r\n-        code = *(ngx_http_script_code_pt *) e->ip;\r\n-        code(e);\r\n-    }\r\n-\r\n-    return e->status;\r\n+    return NGX_ERROR;\r\n }\r\n \r\n \r\n'","b'diff --git a/src/http/ngx_http_script.c b/src/http/ngx_http_script.c\r\nindex 090f39c..5e7acf5 100644\r\n--- a/src/http/ngx_http_script.c\r\n+++ b/src/http/ngx_http_script.c\r\n@@ -1272,6 +1272,7 @@ ngx_http_script_regex_end_code(ngx_http_script_engine_t *e)\r\n                           ""the rewritten URI is too long"");\r\n             e->ip = ngx_http_script_exit;\r\n             e->status = NGX_HTTP_INTERNAL_SERVER_ERROR;\r\n+            return;\r\n         }\r\n \r\n         if (!code->add_args) {\r\n'",b'GET /old/LoremipsumdolorsitametconsecteturadipiscingelitNuncnecviverramaurisMorbiidnequeveljustoegestasdapibusacnullamattisnibhCrasvulputatepretiumloremquispretiumCurabiturcursuseuismodturpisafeugiatNullavitaenimnonsagittisvehiculasuspendissepotentiSedconvallisnonelitsitametplaceratMorbiacmattisloremDuisultriciesmaurisacvenenatisfaucibusVivamusegetmetusnecjustofermentumcondimentumIntegerlobortisnequeeuvestibulumtinciduntligulalectusaNuncsedpurustortorDuisnonlectusvenenatisnullaaccommodoinpulvinarjustoSuspendissefermentumvelitsitametsollicitudinInnibhliberotinciduntvitaevenenatissitametfaucibusquisodioAeneanmalesuadaodiovelipsumsemperquisaliquamidligulaFuscefaucibusvelitnequevitaemagnaUtullamcorperdiamvelorciullamcorperidmaurisatporttitorMorbiposuereidquamconvallisvestibulumMaurisjustonisiutfringillacursusProinfaucibusliberoegetnullavulputateefficiturInidnibhmaurismollisvelitametporttitorsemperDuisvestibulumplaceraterostetporttitorNuncvitaejustocurabitureutemporarcuInultricesultriciespurusSednonsapienloremQuisquenecmetusvehiculaliberoegestasaconvallisauguePraesentetpretiummassaCurabiturutligulamaurisdignissiminterdumPhasellusporttitorpretiumduiMaecenasvelultriciesauguePellentesqueutodiovenenatisfringillafacilisisinecnullaVestibulumvitaeultricesliberoSuspendisseconsequatviverrafelisnecfaucibusMaurisnequemassaporttitorsitametnislaliquamfermentumtortorMorbiintortorvelmauriseuismodfacilisisvitaeacrisusInmolestielectusvelaliquetconsecteturerosliberomalesuadaipsumegetluctusduiTinciduntegettempormetusSuspendisseconguevestibulumnequeetpretiumNullamsodalesnullamperidCrasvitaevariusvelitNuncporttitorligulaquiscommodocongueMaurisidpurustinciduntloremcongueaccumsanUtvelipsumlaciniaeratpretiumsuscipitVestibulumconguevitaeexidtristiqueNuncutmassavenenatisrutrumelitvolutpatSuspendissedolorsemgravidaeunibhInutmassaodiotempusacfermentumquisaliquamgravidaInauctorvariusenimtristiqueultricesDuisvehiculalectusutjustotemporsitametfringillaurnaNamfaucibusconsecteturvestibulumIntegerpretiumsodalesnull.html HTTP/1.0\r\n\r\n'
cpv15,"b'# Overview\r\n\r\nID: cpv15<br>\r\nType: [CWE-787](https://cwe.mitre.org/data/definitions/787.html) Out-of-bounds write<br>\r\nSanitizer: AddressSanitizer: SEGV on unknown address<br>\r\n\r\n# Details\r\n\r\nThis CPV removes code that limits the length of the `src` string to 22 characters in the `ngx_http_userid_get_uid` function of `ngx_http_userid_filter_module.c`. This change indicates a revision in handling the `src` string\'s length or encoding, potentially to allow for decoding base64 strings without a fixed length constraint. The vulnerability exists in this module when an overly long value is provided via the `uid=` option in the Cookie request. This causes an overflow in global memory in a context structure. While the main result of the vulnerability is an overflow, the sanitizer that triggers is a Read Access due to the overwriting of a pointer that is later dereferenced.<br>\r\n\r\nDifficulty to Discover (easy, medium, hard): Easy<br>\r\nDifficulty to Patch (easy, medium, hard): Easy<br>\r\n\r\nThe purpose of this CPV is to demonstrate what could happen if a developer fails to add a simple length check. Therefore, the difficulty of finding this type of vulnerability should not be high for a seasoned code reviewer. This is because knowledge of common vulnerabilities, such as input validation issues, improper use of cryptographic functions, or insufficient data sanitization, can guide the search for the vulnerability in this specific CPV.<br>\r\n\r\nGiven that this is a relatively common occurance, it is important that successful systems are able to detect and mitigate this type of programming error. Therefore, a good patch would involve setting a length limit to a buffer that is being copied to or from another source (In this case, limiting the `src` string to 22 characters).<br>\r\n\r\nThis vulnerability causes NGINX to crash thus denying service to its clients. The intentional crash of a service is called ""Denial of Service"" or DoS.<br>\r\n'","b'pov_harness, AddressSanitizer: SEGV\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Andrey Zelenkov\r\n# (C) Nginx, Inc.\r\n\r\n# Tests for userid filter module.\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nuse Config;\r\nuse MIME::Base64;\r\nuse Time::Local;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nmy $t = Test::Nginx->new()->has(qw/http userid map unix/);\r\n\r\n$t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    map $args $uid_reset {\r\n        default      0;\r\n        value        1;\r\n        log          log;\r\n    }\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        listen       [::1]:%%PORT_8080%%;\r\n        listen       unix:%%TESTDIR%%/unix.sock;\r\n        server_name  localhost;\r\n\r\n        add_header X-Got $uid_got;\r\n        add_header X-Reset $uid_reset;\r\n        add_header X-Set $uid_set;\r\n        userid on;\r\n\r\n        location / {\r\n            error_log %%TESTDIR%%/error.log debug;\r\n            error_log %%TESTDIR%%/error_reset.log info;\r\n        }\r\n\r\n        location /name {\r\n            userid_name test;\r\n        }\r\n\r\n        location /path {\r\n            userid_path /0123456789;\r\n\r\n            location /path/r {\r\n                userid_path /9876543210;\r\n            }\r\n        }\r\n\r\n        location /domain {\r\n            userid_domain test.domain;\r\n        }\r\n\r\n        location /mark_off {\r\n            userid_mark off;\r\n        }\r\n        location /mark_eq {\r\n            userid_mark =;\r\n        }\r\n        location /mark_let {\r\n            userid_mark t;\r\n        }\r\n        location /mark_num {\r\n            userid_mark 9;\r\n        }\r\n\r\n        location /expires_time {\r\n            add_header X-Msec $msec;\r\n            userid_expires 100;\r\n        }\r\n        location /expires_max {\r\n            userid_expires max;\r\n\r\n            location /expires_max/off {\r\n                userid_expires off;\r\n            }\r\n        }\r\n        location /expires_off {\r\n            userid_expires off;\r\n        }\r\n\r\n        location /p3p {\r\n            userid_p3p policyref=""/w3c/p3p.xml"";\r\n        }\r\n\r\n        location /service {\r\n            userid_service 65534;\r\n        }\r\n\r\n        location /cv1 {\r\n            userid v1;\r\n            userid_mark t;\r\n        }\r\n\r\n        location /ip6 {\r\n            userid off;\r\n            proxy_pass http://[::1]:%%PORT_8080%%/;\r\n        }\r\n\r\n        location /unix {\r\n            userid off;\r\n            proxy_pass http://unix:%%TESTDIR%%/unix.sock:/;\r\n        }\r\n\r\n        location /clog {\r\n            userid log;\r\n        }\r\n\r\n        location /coff {\r\n            userid off;\r\n        }\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->write_file(\'index.html\', \'\');\r\n$t->write_file(\'expires_time\', \'\');\r\n$t->write_file(\'service\', \'\');\r\n$t->write_file(\'cv1\', \'\');\r\n$t->write_file(\'clog\', \'\');\r\n$t->write_file(\'coff\', \'\');\r\n$t->try_run(\'no inet6 support\')->plan(35);\r\n\r\n###############################################################################\r\n\r\n# userid\r\n\r\nlike(http_get(\'/\'), qr/Set-Cookie:/, \'cookie on\');\r\nlike(http_get(\'/cv1\'), qr/Set-Cookie:/, \'cookie v1\');\r\nunlike(http_get(\'/clog\'), qr/Set-Cookie:/, \'cookie log\');\r\nunlike(http_get(\'/coff\'), qr/Set-Cookie:/, \'cookie off\');\r\n\r\n# default\r\n\r\nmy %cookie = get_cookie(\'/\');\r\nisnt($cookie{\'uid\'}, undef, \'name default\');\r\nis($cookie{\'path\'}, \'/\', \'path default\');\r\nis($cookie{\'domain\'}, undef, \'domain default\');\r\nis($cookie{\'expires\'}, undef, \'expires default\');\r\nlike($cookie{\'uid\'}, \'/\\w+={0,2}$/\', \'mark default\');\r\nunlike(http_get(\'/\'), qr/^P3P/m, \'p3p default\');\r\nlike(http_get(\'/\'), qr/X-Reset: 0/, \'uid reset variable default\');\r\n\r\n# name, path, domain and p3p\r\n\r\nisnt(get_cookie(\'/name\', \'test\'), undef, \'name\');\r\nis(get_cookie(\'/path\', \'path\'), \'/0123456789\', \'path\');\r\nis(get_cookie(\'/domain\', \'domain\'), \'test.domain\', \'domain\');\r\nlike(http_get(\'/p3p\'), qr!P3P: policyref=""/w3c/p3p.xml""!, \'p3p\');\r\n\r\n# mark\r\n\r\nlike(get_cookie(\'/mark_off\', \'uid\'), \'/\\w+={0,2}$/\', \'mark off\');\r\nlike(get_cookie(\'/mark_eq\', \'uid\'), \'/==$/\', \'mark equal\');\r\nlike(get_cookie(\'/mark_let\', \'uid\'), \'/t=$/\', \'mark letter\');\r\nlike(get_cookie(\'/mark_num\', \'uid\'), \'/9=$/\', \'mark number\');\r\n\r\n# expires\r\n\r\nmy $r = http_get(\'/expires_time\');\r\nmy ($t1) = $r =~ /X-Msec: (\\d+)/;\r\nis(expires2timegm(cookie($r, \'expires\')), $t1 + 100, \'expires time\');\r\nis(get_cookie(\'/expires_max\', \'expires\'), \'Thu, 31-Dec-37 23:55:55 GMT\',\r\n\t\'expires max\');\r\nis(get_cookie(\'/expires_off\', \'expires\'), undef, \'expires off\');\r\n\r\n# redefinition\r\n\r\nunlike(http_get(\'/expires_max/off\'), qr/expires/, \'redefine expires\');\r\nlike(http_get(\'/path/r\'), qr!/9876543210!, \'redefine path\');\r\n\r\n# requests\r\n\r\n$r = http_get(\'/\');\r\nmy ($uid) = uid_set($r);\r\nisnt($uid, undef, \'uid set variable\');\r\n\r\n$r = send_uid(\'/\', cookie($r, \'uid\'));\r\nis(uid_got($r), $uid, \'uid got variable\');\r\nunlike($r, qr/Set-Cookie:/, \'same path request\');\r\n\r\n$r = send_uid(\'/coff\', $uid);\r\nunlike($r, qr/Set-Cookie:/, \'other path request\');\r\n\r\n$r = send_uid(\'/?value\', $uid);\r\nlike($r, qr/Set-Cookie:/, \'uid reset variable value\');\r\n\r\n# service\r\n\r\nis(substr(uid_set(http_get(\'/cv1\')), 0, 8), \'00000000\', \'service default v1\');\r\n\r\nmy $bigendian = $Config{byteorder} =~ \'1234\' ? 0 : 1;\r\nmy $addr = $bigendian ? ""7F000001"" : ""0100007F"";\r\nis(substr(uid_set(http_get(\'/\')), 0, 8), $addr, \'service default v2\');\r\n\r\n$addr = $bigendian ? ""0000FFFE"" : ""FEFF0000"";\r\nis(substr(uid_set(http_get(\'/service\')), 0, 8), $addr, \'service custom\');\r\n\r\n$addr = $bigendian ? ""00000001"" : ""01000000"";\r\nis(substr(uid_set(http_get(\'/ip6\')), 0, 8), $addr, \'service ipv6\');\r\n\r\nis(substr(uid_set(http_get(\'/unix\')), 0, 8), ""00000000"", \'service unix\');\r\n\r\n# reset log\r\n\r\nsend_uid(\'/?log\', cookie($r, \'uid\'));\r\n\r\n$t->stop();\r\n\r\nlike($t->read_file(\'error_reset.log\'),\r\n\t\'/userid cookie ""uid=\\w+"" was reset/m\', \'uid reset variable log\');\r\n\r\n###############################################################################\r\n\r\nsub cookie {\r\n\tmy ($r, $key) = @_;\r\n\tmy %cookie;\r\n\r\n\t$r =~ /(Set-Cookie:[^\\x0d]*).*\\x0d\\x0a?\\x0d/ms;\r\n\tif ($1) {\r\n\t\t%cookie = $1 =~ /(\\w+)=([^;]+)/g;\r\n\t}\r\n\r\n\treturn $cookie{$key} if defined $key;\r\n\treturn %cookie;\r\n}\r\n\r\nsub get_cookie {\r\n\tmy ($url, $key) = @_;\r\n\treturn cookie(http_get($url), $key);\r\n}\r\n\r\nsub expires2timegm {\r\n\tmy ($e) = @_;\r\n\tmy %months = (Jan => 0, Feb => 1, Mar => 2, Apr => 3, May =>4, Jun => 5,\r\n\t\tJul => 6, Aug => 7, Sep => 8, Oct => 9, Nov => 10, Dec => 11);\r\n\r\n\tmy ($w, $date, $time) = split("" "", $e);\r\n\tmy ($day, $month, $year) = split(""-"", $date);\r\n\tmy ($hour, $min, $sec) = split("":"", $time);\r\n\r\n\treturn timegm($sec, $min, $hour, $day, $months{$month}, $year);\r\n}\r\n\r\nsub uid_set {\r\n\tmy ($r) = @_;\r\n\tmy ($uid) = $r =~ /X-Set: uid=(.*)\\n/m;\r\n\treturn $uid;\r\n}\r\n\r\nsub uid_got {\r\n\tmy ($r) = @_;\r\n\tmy ($uid) = $r =~ /X-Got: uid=(.*)\\n/m;\r\n\treturn $uid;\r\n}\r\n\r\nsub send_uid {\r\n\tmy ($url, $uid) = @_;\r\n\treturn http(<<EOF);\r\nGET $url HTTP/1.0\r\nHost: localhost\r\nCookie: uid=$uid\r\n\r\nEOF\r\n}\r\n\r\n###############################################################################\r\n'","b'diff --git a/src/http/modules/ngx_http_userid_filter_module.c b/src/http/modules/ngx_http_userid_filter_module.c\r\nindex 07163a0..2ef99f1 100644\r\n--- a/src/http/modules/ngx_http_userid_filter_module.c\r\n+++ b/src/http/modules/ngx_http_userid_filter_module.c\r\n@@ -319,58 +319,7 @@ ngx_http_userid_set_variable(ngx_http_request_t *r,\r\n static ngx_http_userid_ctx_t *\r\n ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\r\n {\r\n-    ngx_str_t               src, dst;\r\n-    ngx_table_elt_t        *cookie;\r\n-    ngx_http_userid_ctx_t  *ctx;\r\n-\r\n-    ctx = ngx_http_get_module_ctx(r, ngx_http_userid_filter_module);\r\n-\r\n-    if (ctx) {\r\n-        return ctx;\r\n-    }\r\n-\r\n-    if (ctx == NULL) {\r\n-        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_userid_ctx_t));\r\n-        if (ctx == NULL) {\r\n-            return NULL;\r\n-        }\r\n-\r\n-        ngx_http_set_ctx(r, ctx, ngx_http_userid_filter_module);\r\n-    }\r\n-\r\n-    cookie = ngx_http_parse_multi_header_lines(r, r->headers_in.cookie,\r\n-                                               &conf->name, &ctx->cookie);\r\n-    if (cookie == NULL) {\r\n-        return ctx;\r\n-    }\r\n-\r\n-    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\r\n-                   ""uid cookie: \\""%V\\"""", &ctx->cookie);\r\n-\r\n-    if (ctx->cookie.len < 22) {\r\n-        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\r\n-                      ""client sent too short userid cookie \\""%V\\"""",\r\n-                      &cookie->value);\r\n-        return ctx;\r\n-    }\r\n-\r\n-    src = ctx->cookie;\r\n-\r\n-    dst.data = (u_char *) ctx->uid_got;\r\n-\r\n-    if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\r\n-        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\r\n-                      ""client sent invalid userid cookie \\""%V\\"""",\r\n-                      &cookie->value);\r\n-        return ctx;\r\n-    }\r\n-\r\n-    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\r\n-                   ""uid: %08XD%08XD%08XD%08XD"",\r\n-                   ctx->uid_got[0], ctx->uid_got[1],\r\n-                   ctx->uid_got[2], ctx->uid_got[3]);\r\n-\r\n-    return ctx;\r\n+    return NULL;\r\n }\r\n \r\n \r\n'","b'diff --git a/src/http/modules/ngx_http_userid_filter_module.c b/src/http/modules/ngx_http_userid_filter_module.c\r\nindex 07163a0..5a48d23 100644\r\n--- a/src/http/modules/ngx_http_userid_filter_module.c\r\n+++ b/src/http/modules/ngx_http_userid_filter_module.c\r\n@@ -356,6 +356,8 @@ ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\r\n \r\n     src = ctx->cookie;\r\n \r\n+    src.len = 22;\r\n+\r\n     dst.data = (u_char *) ctx->uid_got;\r\n \r\n     if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\r\n'",b'GET / HTTP/1.1\r\nHost: localhost\r\nCookie: uid=YWFhYWFhYWFhYWFhYWFhYWJiYmJiYmJiYmJiYmJiYmJjY2NjY2NjY2NjY2NjY2Nj;;\r\n\r\n'
cpv17,"b'# Overview\r\n\r\nID: cpv17<br>\r\nType: [CWE-416](https://cwe.mitre.org/data/definitions/416.html) Use After Free<br>\r\nSanitizer: AddressSanitizer: heap-use-after-free<br>\r\n\r\n# Details\r\n\r\nA new SMTP response message for the NOOP command is added. The NOOP command handling is integrated into the `ngx_mail_smtp_auth_state` function. The `ngx_mail_smtp_noop` function is defined, which checks if the number of arguments exceeds 10. If so, it sets an invalid argument error and closes the connection. Otherwise, it responds with the `smtp_noop` message. The function appears to handle this correctly by first closing the connection and then destroying the pool. However, since `NGX_ERROR` gets returned, it is caught by another check that then calls `ngx_mail_session_internal_server_error`. This function attempts to access the freed connection structure, which leads to a crash via a UAF.<br>\r\n\r\nDifficulty to Discover (easy, medium, hard): Hard<br>\r\nDifficulty to Patch (easy, medium, hard): Easy<br>\r\n\r\nThe nature of a Use-After_free vulnerability is what makes it difficult to find (especially if all you have access to is the source code). This is due to the fact that large and complex codebases can make it difficult to track memory allocations and deallocations, leading to potential use-after-free issues being overlooked. Manual code review relies on the thoroughness and expertise of the reviewer, but humans can miss these bugs, especially in complex or unfamiliar code.<br>\r\n\r\nA good patch will ensure that no references to the freed memory are accessed after the `ngx_destroy_pool` call. This can easily be done by simply not prematurely closing the connection (assuming the reviewer knows that `ngx_mail_close-connection` destroys the memory pool). This is because closing a connection usually occurs in the handler of each module, and not the functions called by the handler. By doing this we ensure that any subsequent access to this pointer will be safely handled, thereby preventing a use-after-free scenario. This will look like the removal of the line of code that calls `ngx_mail_close_connection` in `ngx_mail_smtp_noop`.<br>\r\n\r\nThis vulnerability causes NGINX to crash thus denying service to its clients. The intentional crash of a service is called ""Denial of Service"" or DoS.<br>\r\n'","b'smtp_harness, AddressSanitizer: heap-use-after-free\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n\r\n# Tests for nginx mail smtp module.\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nuse MIME::Base64;\r\nuse Socket qw/ CRLF /;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\nuse Test::Nginx::SMTP;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nlocal $SIG{PIPE} = \'IGNORE\';\r\n\r\nmy $t = Test::Nginx->new()->has(qw/mail smtp http rewrite/)\r\n\t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nmail {\r\n    proxy_pass_error_message  on;\r\n    proxy_timeout  15s;\r\n    auth_http  http://127.0.0.1:8080/mail/auth;\r\n    xclient    off;\r\n\r\n    server {\r\n        listen     127.0.0.1:8025;\r\n        protocol   smtp;\r\n        smtp_auth  login plain none cram-md5 external;\r\n    }\r\n\r\n    server {\r\n        listen     127.0.0.1:8027;\r\n        protocol   smtp;\r\n        smtp_auth  none;\r\n        smtp_client_buffer 128;\r\n    }\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n\r\n        location = /mail/auth {\r\n            set $reply ERROR;\r\n\r\n            if ($http_auth_smtp_to ~ example.com) {\r\n                set $reply OK;\r\n            }\r\n\r\n            set $userpass ""$http_auth_user:$http_auth_pass"";\r\n            if ($userpass ~ \'^test@example.com:secret$\') {\r\n                set $reply OK;\r\n            }\r\n\r\n            set $userpass ""$http_auth_user:$http_auth_salt:$http_auth_pass"";\r\n            if ($userpass ~ \'^test@example.com:<.*@.*>:0{32}$\') {\r\n                set $reply OK;\r\n            }\r\n\r\n            set $userpass ""$http_auth_method:$http_auth_user:$http_auth_pass"";\r\n            if ($userpass ~ \'^external:test@example.com:$\') {\r\n                set $reply OK;\r\n            }\r\n\r\n            add_header Auth-Status $reply;\r\n            add_header Auth-Server 127.0.0.1;\r\n            add_header Auth-Port %%PORT_8026%%;\r\n            add_header Auth-Wait 1;\r\n            return 204;\r\n        }\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->run_daemon(\\&Test::Nginx::SMTP::smtp_test_daemon);\r\n$t->run()->plan(42);\r\n\r\n$t->waitforsocket(\'127.0.0.1:\' . port(8026));\r\n\r\n###############################################################################\r\n\r\nmy $s = Test::Nginx::SMTP->new();\r\n$s->check(qr/^220 /, ""greeting"");\r\n\r\n$s->send(\'EHLO example.com\');\r\n$s->check(qr/^250 /, ""ehlo"");\r\n\r\n$s->send(\'AUTH PLAIN \' . encode_base64(""\\0test\\@example.com\\0bad"", \'\'));\r\n$s->check(qr/^5.. /, \'auth plain with bad password\');\r\n\r\n$s->send(\'AUTH PLAIN \' . encode_base64(""\\0test\\@example.com\\0secret"", \'\'));\r\n$s->authok(\'auth plain\');\r\n\r\n# We are talking to backend from this point\r\n\r\n$s->send(\'MAIL FROM:<test@example.com> SIZE=100\');\r\n$s->ok(\'mail from after auth\');\r\n\r\n$s->send(\'RSET\');\r\n$s->ok(\'rset\');\r\n\r\n$s->send(\'MAIL FROM:<test@xn--e1afmkfd.xn--80akhbyknj4f> SIZE=100\');\r\n$s->ok(""idn mail from (example.test in russian)"");\r\n\r\n$s->send(\'QUIT\');\r\n$s->ok(""quit"");\r\n\r\n# Try auth login in simple form\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n$s->send(\'EHLO example.com\');\r\n$s->read();\r\n\r\n$s->send(\'AUTH LOGIN\');\r\n$s->check(qr/^334 VXNlcm5hbWU6/, \'auth login simple username challenge\');\r\n$s->send(encode_base64(\'test@example.com\', \'\'));\r\n$s->check(qr/^334 UGFzc3dvcmQ6/, \'auth login simple password challenge\');\r\n$s->send(encode_base64(\'secret\', \'\'));\r\n$s->authok(\'auth login simple\');\r\n\r\n# Try auth plain with username.  Details:\r\n#\r\n# [MS-XLOGIN]: SMTP Protocol AUTH LOGIN Extension Specification\r\n# http://download.microsoft.com/download/5/D/D/5DD33FDF-91F5-496D-9884-0A0B0EE698BB/%5BMS-XLOGIN%5D.pdf\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n$s->send(\'EHLO example.com\');\r\n$s->read();\r\n\r\n$s->send(\'AUTH LOGIN \' . encode_base64(\'test@example.com\', \'\'));\r\n$s->check(qr/^334 UGFzc3dvcmQ6/, \'auth login with username password challenge\');\r\n$s->send(encode_base64(\'secret\', \'\'));\r\n$s->authok(\'auth login with username\');\r\n\r\n# Try auth cram-md5\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n$s->send(\'EHLO example.com\');\r\n$s->read();\r\n\r\n$s->send(\'AUTH CRAM-MD5\');\r\n$s->check(qr/^334 /, \'auth cram-md5 challenge\');\r\n$s->send(encode_base64(\'test@example.com \' . (\'0\' x 32), \'\'));\r\n$s->authok(\'auth cram-md5\');\r\n\r\n# Try auth external\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n$s->send(\'EHLO example.com\');\r\n$s->read();\r\n\r\n$s->send(\'AUTH EXTERNAL\');\r\n$s->check(qr/^334 VXNlcm5hbWU6/, \'auth external challenge\');\r\n$s->send(encode_base64(\'test@example.com\', \'\'));\r\n$s->ok(\'auth external\');\r\n\r\n# Try auth external with username\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n$s->send(\'EHLO example.com\');\r\n$s->read();\r\n\r\n$s->send(\'AUTH EXTERNAL \' . encode_base64(\'test@example.com\', \'\'));\r\n$s->ok(\'auth external with username\');\r\n\r\n# Try auth plain with pipelining\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n$s->send(\'EHLO example.com\');\r\n$s->read();\r\n\r\n$s->send(\'INVALID COMMAND WITH ARGUMENTS\' . CRLF\r\n\t. \'RSET\');\r\n$s->read();\r\n$s->ok(\'pipelined rset after invalid command\');\r\n\r\n$s->send(\'AUTH PLAIN \'\r\n\t. encode_base64(""\\0test\\@example.com\\0bad"", \'\') . CRLF\r\n\t. \'MAIL FROM:<test@example.com> SIZE=100\');\r\n$s->read();\r\n$s->ok(\'mail from after failed pipelined auth\');\r\n\r\n$s->send(\'AUTH PLAIN \'\r\n\t. encode_base64(""\\0test\\@example.com\\0secret"", \'\') . CRLF\r\n\t. \'MAIL FROM:<test@example.com> SIZE=100\');\r\n$s->read();\r\n$s->ok(\'mail from after pipelined auth\');\r\n\r\n# Try auth none\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n$s->send(\'EHLO example.com\');\r\n$s->read();\r\n\r\n$s->send(\'MAIL FROM:<test@example.com> SIZE=100\');\r\n$s->ok(\'auth none - mail from\');\r\n\r\n$s->send(\'RCPT TO:<test@example.com>\');\r\n$s->ok(\'auth none - rcpt to\');\r\n\r\n$s->send(\'RSET\');\r\n$s->ok(\'auth none - rset, should go to backend\');\r\n\r\n# Auth none with pipelining\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n$s->send(\'EHLO example.com\');\r\n$s->read();\r\n\r\n$s->send(\'MAIL FROM:<test@example.com> SIZE=100\' . CRLF\r\n\t. \'RCPT TO:<test@example.com>\' . CRLF\r\n\t. \'RSET\');\r\n\r\n$s->ok(\'pipelined mail from\');\r\n$s->ok(\'pipelined rcpt to\');\r\n$s->ok(\'pipelined rset\');\r\n\r\n# Pipelining with split command\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n$s->send(\'EHLO example.com\');\r\n$s->read();\r\n\r\n$s->print(\'MAIL FROM:<test@example.com> SIZE=100\' . CRLF\r\n\t. \'RCPT TO:<test@example.com>\' . CRLF\r\n\t. \'RS\');\r\n$s->ok(\'split pipelined mail from\');\r\n$s->ok(\'split pipelined rcpt to\');\r\n\r\n$s->send(\'ET\');\r\n$s->ok(\'split pipelined rset\');\r\n\r\n# Pipelining longer than smtp_client_buffer\r\n\r\n$s = Test::Nginx::SMTP->new(PeerAddr => \'127.0.0.1:\' . port(8027));\r\n$s->read();\r\n$s->send(\'EHLO example.com\');\r\n$s->read();\r\n\r\n$s->send(\'MAIL FROM:<test@example.com> SIZE=100\' . CRLF\r\n\t. \'RCPT TO:<foo@example.com>\' . CRLF\r\n\t. \'RCPT TO:<bar@example.com>\' . CRLF\r\n\t. \'RCPT TO:<baz@example.com>\' . CRLF\r\n\t. \'RCPT TO:<foobar@example.com>\' . CRLF\r\n\t. \'RSET\');\r\n$s->ok(\'long pipelined mail from\');\r\n$s->ok(\'long pipelined rcpt to\');\r\n$s->ok(\'long pipelined rcpt to 2\');\r\n$s->ok(\'long pipelined rcpt to 3\');\r\n$s->ok(\'long pipelined rcpt to 4\');\r\n$s->ok(\'long pipelined rset\');\r\n\r\n# Connection must stay even if error returned to rcpt to command\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n$s->send(\'EHLO example.com\');\r\n$s->read();\r\n\r\n$s->send(\'MAIL FROM:<test@example.com> SIZE=100\');\r\n$s->read(); # skip mail from reply\r\n\r\n$s->send(\'RCPT TO:<example.com>\');\r\n$s->check(qr/^5.. /, ""bad rcpt to"");\r\n\r\n$s->send(\'RCPT TO:<test@example.com>\');\r\n$s->ok(\'good rcpt to\');\r\n\r\n# Make sure command split into many packets processed correctly\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n\r\n$s->print(\'HEL\');\r\nselect undef, undef, undef, 0.1;\r\n$s->send(\'O example.com\');\r\n$s->ok(\'split command\');\r\n\r\n# Invalid command split into many packets\r\n\r\n$s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n\r\n$s->print(\'FOO B\');\r\nselect undef, undef, undef, 0.1;\r\n$s->send(\'AR\');\r\n$s->check(qr/^5.. /, \'invalid split command\');\r\n\r\n$s->send(\'HELO example.com\');\r\n$s->ok(\'good after invalid split command\');\r\n\r\n# Make sure NOOP debugging feature is working correctly\r\n\r\nmy $s = Test::Nginx::SMTP->new();\r\n$s->read();\r\n$s->send(\'NOOP\');\r\n$s->check(qr/^255 /, ""noop"");\r\n\r\n###############################################################################\r\n'","b'diff --git a/src/mail/ngx_mail_smtp_handler.c b/src/mail/ngx_mail_smtp_handler.c\r\nindex a7d4012..7c30495 100644\r\n--- a/src/mail/ngx_mail_smtp_handler.c\r\n+++ b/src/mail/ngx_mail_smtp_handler.c\r\n@@ -37,7 +37,6 @@ static void ngx_mail_smtp_log_rejected_command(ngx_mail_session_t *s,\r\n \r\n \r\n static u_char  smtp_ok[] = ""250 2.0.0 OK"" CRLF;\r\n-static u_char  smtp_noop[] = ""255 2.0.0 OK"" CRLF;\r\n static u_char  smtp_bye[] = ""221 2.0.0 Bye"" CRLF;\r\n static u_char  smtp_starttls[] = ""220 2.0.0 Start TLS"" CRLF;\r\n static u_char  smtp_next[] = ""334 "" CRLF;\r\n@@ -831,14 +830,7 @@ ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c)\r\n static ngx_int_t\r\n ngx_mail_smtp_noop(ngx_mail_session_t *s, ngx_connection_t *c)\r\n {\r\n-    if (s->args.nelts > 10) {\r\n-        ngx_str_set(&s->out, smtp_invalid_argument);\r\n-        ngx_mail_close_connection(c);\r\n-        return NGX_ERROR;\r\n-    }\r\n-\r\n-    ngx_str_set(&s->out, smtp_noop);\r\n-    return NGX_OK;\r\n+    return NGX_ERROR;\r\n }\r\n \r\n \r\n'","b'diff --git a/src/mail/ngx_mail_smtp_handler.c b/src/mail/ngx_mail_smtp_handler.c\r\nindex a7d4012..201da8f 100644\r\n--- a/src/mail/ngx_mail_smtp_handler.c\r\n+++ b/src/mail/ngx_mail_smtp_handler.c\r\n@@ -833,7 +833,6 @@ ngx_mail_smtp_noop(ngx_mail_session_t *s, ngx_connection_t *c)\r\n {\r\n     if (s->args.nelts > 10) {\r\n         ngx_str_set(&s->out, smtp_invalid_argument);\r\n-        ngx_mail_close_connection(c);\r\n         return NGX_ERROR;\r\n     }\r\n \r\n'",b'NOOP f f f f f f f f f f f\r\n'
cpv2,"b'# Overview\r\nID: cpv2   \r\nType: [CWE-122](https://cwe.mitre.org/data/definitions/122.html) Heap-based Buffer Overflow  \r\nSanitizer: AddressSanitizer: heap-buffer-overflow  \r\n\r\n# Details\r\n\r\nThe Basic Auth header is a component of the HTTP protocol used for simple access control. When a user requests access to a protected resource, if unallowed, the server responds with a 401 Unauthorized status and a WWW-Authenticate header. The client could then send a request with an Authorization header containing the word Basic followed by a space and a base64-encoded string username:password. This allows the server to decode the credentials and verify the user\'s identity.\r\n\r\nYou could manually perform this operation with the shell command ``curl -H ""Authorization: Basic $(echo -n ""myuser:mypassword"" | base64)"" localhost:9999``. If you have a netcat listener you will receive the following request:\r\n```\r\nGET / HTTP/1.1\r\nHost: localhost:9999\r\nUser-Agent: curl/7.81.0\r\nAccept: */*\r\nAuthorization: Basic bXl1c2VyOm15cGFzc3dvcmQ=\r\n``` \r\n\r\nThe vulnerability is in how nginx handles the basic authentication header. The attacker sends a base64 encoded string but the nginx server has a statically size buffer into which it decodes the base64. This results in a heap base buffer overflow. The purpose of this is for systems to detect when a dynamic buffer is allocated with a non-dynamic length and the developer fails to include sufficient checks on the length of user input. This is a fairly fundamental problem and common occurrence that systems should be able to detect and mitigate.\r\n'","b'pov_harness, AddressSanitizer: heap-buffer-overflow\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n\r\n# Tests for auth basic module.\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nuse MIME::Base64;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nmy $t = Test::Nginx->new()->has(qw/http auth_basic/)->plan(24)\r\n\t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n\r\n        location / {\r\n            auth_basic           ""closed site"";\r\n            auth_basic_user_file %%TESTDIR%%/htpasswd;\r\n\r\n            location /inner {\r\n                auth_basic off;\r\n                alias %%TESTDIR%%/;\r\n            }\r\n\r\n            location /var {\r\n                # prepended with conf_prefix\r\n                auth_basic_user_file $arg_f;\r\n                alias %%TESTDIR%%/;\r\n\t    }\r\n        }\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->write_file(\'index.html\', \'SEETHIS\');\r\n\r\n$t->write_file(\r\n\t\'htpasswd\',\r\n\t\'crypt:\' . (crypt(\'password\', \'salt\') || \'\') . ""\\n"" .\r\n\t\'crypt1:\' . (crypt(\'password\', \'$1$salt$\') || \'\') . ""\\n"" .\r\n\t\'crypt2:\' . \'$1$\' . ""\\n"" .\r\n\t\'apr1:\' . \'$apr1$salt$Xxd1irWT9ycqoYxGFn4cb.\' . ""\\n"" .\r\n\t\'apr12:\' . \'$apr1$\' . ""\\n"" .\r\n\t\'plain:\' . \'{PLAIN}password\' . ""\\n"" .\r\n\t\'ssha:\' . \'{SSHA}yI6cZwQadOA1e+/f+T+H3eCQQhRzYWx0\' . ""\\n"" .\r\n\t\'ssha2:\' . \'{SSHA}_____wQadOA1e+/f+T+H3eCQQhRzYWx0\' . ""\\n"" .\r\n\t\'ssha3:\' . \'{SSHA}Zm9vCg==\' . ""\\n"" .\r\n\t\'sha:\' . \'{SHA}W6ph5Mm5Pz8GgiULbPgzG37mj9g=\' . ""\\n"" .\r\n\t\'sha2:\' . \'{SHA}_____Mm5Pz8GgiULbPgzG37mj9g=\' . ""\\n"" .\r\n\t\'sha3:\' . \'{SHA}Zm9vCg==\' . ""\\n""\r\n);\r\n\r\n$t->run();\r\n\r\n###############################################################################\r\n\r\nlike(http_get(\'/\'), qr!401 Unauthorized!ms, \'rejects unathorized\');\r\n\r\nSKIP: {\r\n\r\nskip \'no crypt on win32\', 5 if $^O eq \'MSWin32\';\r\n\r\nlike(http_get_auth(\'/\', \'crypt\', \'password\'), qr!SEETHIS!, \'normal crypt\');\r\nunlike(http_get_auth(\'/\', \'crypt\', \'123\'), qr!SEETHIS!, \'normal wrong\');\r\n\r\nlike(http_get_auth(\'/\', \'crypt1\', \'password\'), qr!SEETHIS!, \'crypt $1$ (md5)\');\r\nunlike(http_get_auth(\'/\', \'crypt1\', \'123\'), qr!SEETHIS!, \'crypt $1$ wrong\');\r\n\r\nlike(http_get_auth(\'/\', \'crypt2\', \'1\'), qr!401 Unauthorized!,\r\n\t\'crypt $1$ broken\');\r\n\r\n}\r\n\r\nlike(http_get_auth(\'/\', \'apr1\', \'password\'), qr!SEETHIS!, \'apr1 md5\');\r\nlike(http_get_auth(\'/\', \'plain\', \'password\'), qr!SEETHIS!, \'plain password\');\r\nlike(http_get_auth(\'/\', \'ssha\', \'password\'), qr!SEETHIS!, \'ssha\');\r\nlike(http_get_auth(\'/\', \'sha\', \'password\'), qr!SEETHIS!, \'sha\');\r\n\r\nunlike(http_get_auth(\'/\', \'apr1\', \'123\'), qr!SEETHIS!, \'apr1 md5 wrong\');\r\nunlike(http_get_auth(\'/\', \'plain\', \'123\'), qr!SEETHIS!, \'plain wrong\');\r\nunlike(http_get_auth(\'/\', \'ssha\', \'123\'), qr!SEETHIS!, \'ssha wrong\');\r\nunlike(http_get_auth(\'/\', \'sha\', \'123\'), qr!SEETHIS!, \'sha wrong\');\r\n\r\nlike(http_get_auth(\'/\', \'apr12\', \'1\'), qr!401 Unauthorized!, \'apr1 md5 broken\');\r\nlike(http_get_auth(\'/\', \'ssha2\', \'1\'), qr!401 Unauthorized!, \'ssha broken 1\');\r\nlike(http_get_auth(\'/\', \'ssha3\', \'1\'), qr!401 Unauthorized!, \'ssha broken 2\');\r\nlike(http_get_auth(\'/\', \'sha2\', \'1\'), qr!401 Unauthorized!, \'sha broken 1\');\r\nlike(http_get_auth(\'/\', \'sha3\', \'1\'), qr!401 Unauthorized!, \'sha broken 2\');\r\n\r\nlike(http_get_auth(\'/\', \'notfound\', \'1\'), qr!401 Unauthorized!, \'not found\');\r\nlike(http_get(\'/inner/\'), qr!SEETHIS!, \'inner off\');\r\n\r\nlike(http_get_auth(\'/var/?f=htpasswd\', \'apr1\', \'password\'), qr!SEETHIS!,\r\n\t\'user file variable\');\r\nunlike(http_get_auth(\'/var/?f=nx\', \'apr1\', \'password\'), qr!SEETHIS!,\r\n\t\'user file variable not found\');\r\nunlike(http_get_auth(\'/var/\', \'apr1\', \'password\'), qr!SEETHIS!,\r\n\t\'user file variable bad value\');\r\n\r\n###############################################################################\r\n\r\nsub http_get_auth {\r\n\tmy ($url, $user, $password) = @_;\r\n\r\n\tmy $auth = encode_base64($user . \':\' . $password, \'\');\r\n\r\n\treturn http(<<EOF);\r\nGET $url HTTP/1.0\r\nHost: localhost\r\nAuthorization: Basic $auth\r\n\r\nEOF\r\n}\r\n\r\n###############################################################################\r\n'","b'diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c\r\nindex f7ab9aa..e8e9243 100644\r\n--- a/src/http/ngx_http_core_module.c\r\n+++ b/src/http/ngx_http_core_module.c\r\n@@ -1949,72 +1949,7 @@ ngx_http_map_uri_to_path(ngx_http_request_t *r, ngx_str_t *path,\r\n ngx_int_t\r\n ngx_http_auth_basic_user(ngx_http_request_t *r)\r\n {\r\n-    ngx_str_t   auth, encoded;\r\n-    ngx_uint_t  len;\r\n-\r\n-    if (r->headers_in.user.len == 0 && r->headers_in.user.data != NULL) {\r\n-        return NGX_DECLINED;\r\n-    }\r\n-\r\n-    if (r->headers_in.authorization == NULL) {\r\n-        r->headers_in.user.data = (u_char *) """";\r\n-        return NGX_DECLINED;\r\n-    }\r\n-\r\n-    encoded = r->headers_in.authorization->value;\r\n-\r\n-    if (encoded.len < sizeof(""Basic "") - 1\r\n-        || ngx_strncasecmp(encoded.data, (u_char *) ""Basic "",\r\n-                           sizeof(""Basic "") - 1)\r\n-           != 0)\r\n-    {\r\n-        r->headers_in.user.data = (u_char *) """";\r\n-        return NGX_DECLINED;\r\n-    }\r\n-\r\n-    encoded.len -= sizeof(""Basic "") - 1;\r\n-    encoded.data += sizeof(""Basic "") - 1;\r\n-\r\n-    while (encoded.len && encoded.data[0] == \' \') {\r\n-        encoded.len--;\r\n-        encoded.data++;\r\n-    }\r\n-\r\n-    if (encoded.len == 0) {\r\n-        r->headers_in.user.data = (u_char *) """";\r\n-        return NGX_DECLINED;\r\n-    }\r\n-\r\n-    auth.len = NGX_HTTP_AUTH_MAX;\r\n-    auth.data = ngx_pnalloc(r->pool, auth.len + 1);\r\n-    if (auth.data == NULL) {\r\n-        return NGX_ERROR;\r\n-    }\r\n-\r\n-    if (ngx_decode_base64(&auth, &encoded) != NGX_OK) {\r\n-        r->headers_in.user.data = (u_char *) """";\r\n-        return NGX_DECLINED;\r\n-    }\r\n-\r\n-    auth.data[auth.len] = \'\\0\';\r\n-\r\n-    for (len = 0; len < auth.len; len++) {\r\n-        if (auth.data[len] == \':\') {\r\n-            break;\r\n-        }\r\n-    }\r\n-\r\n-    if (len == 0 || len == auth.len) {\r\n-        r->headers_in.user.data = (u_char *) """";\r\n-        return NGX_DECLINED;\r\n-    }\r\n-\r\n-    r->headers_in.user.len = len;\r\n-    r->headers_in.user.data = auth.data;\r\n-    r->headers_in.passwd.len = auth.len - len - 1;\r\n-    r->headers_in.passwd.data = &auth.data[len + 1];\r\n-\r\n-    return NGX_OK;\r\n+    return NGX_DECLINED;\r\n }\r\n \r\n \r\n'","b'diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c\r\nindex f7ab9aa..d6b623d 100644\r\n--- a/src/http/ngx_http_core_module.c\r\n+++ b/src/http/ngx_http_core_module.c\r\n@@ -1985,7 +1985,7 @@ ngx_http_auth_basic_user(ngx_http_request_t *r)\r\n         return NGX_DECLINED;\r\n     }\r\n \r\n-    auth.len = NGX_HTTP_AUTH_MAX;\r\n+    auth.len = ngx_base64_decoded_length(encoded.len);\r\n     auth.data = ngx_pnalloc(r->pool, auth.len + 1);\r\n     if (auth.data == NULL) {\r\n         return NGX_ERROR;\r\n'",b'GET / HTTP/1.1\nHost: localhost\nAuthorization: Basic eW9sb2FhYWFhYWFhYWFhOnBhc3NhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFh\r\n\r\n'
cpv3,"b'# Overview\r\nID: cpv3   \r\nType: [CWE-787](https://cwe.mitre.org/data/definitions/787.html) Out of Bounds Write     \r\nSanitizer: AddressSanitizer: heap-buffer-overflow    \r\n\r\n# Details\r\n\r\n## Modification in Request Processing:\r\n\r\nPreviously, if a TRACE request was received, NGINX would log the event and immediately finalize the request with a 405 Method Not Allowed response, stopping further processing. The patch changes this behavior to call a new function ``ngx_http_trace_handler`` when a TRACE method is detected.\r\n\r\n## New Handler Implementation (``ngx_http_trace_handler``):\r\n\r\nThe handler begins by allocating a buffer of 200 bytes using ``ngx_create_temp_buf``. This buffer is intended to accumulate the entire request line and headers to echo them back to the client. It then iterates over all received HTTP headers, appending each header and its value to the buffer, formatted correctly with newlines. After processing all headers, it sets up the response headers, including setting the Content-Type to message/http and calculating the Content-Length based on the accumulated length of the request line and headers. The response is sent using ``ngx_http_output_filter``, and the request is closed.\r\n\r\n## Vulnerability \r\n\r\nThe initial allocation of a 200-byte buffer does not account for the potential size of the request line and headers. Given that the buffer is populated in a loop over the headers, and no bounds checking is implemented during this loop, this leads to a significant risk of buffer overflow. The overflow of this buffer by approximately 409 bytes leads to heap memory corruption. This occurs because the memory adjacent to the allocated buffer, which could be used by other parts of NGINX or by the underlying system libraries (like libc), is overwritten.\r\n'","b'pov_harness, AddressSanitizer: heap-buffer-overflow\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Sergey Kandaurov\r\n# (C) Nginx, Inc.\r\n\r\n# Tests for HTTP/2 protocol [RFC7540].\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nuse Socket qw/ CRLF /;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\nuse Test::Nginx::HTTP2;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nmy $t = Test::Nginx->new()->has(qw/http http_v2 proxy rewrite charset gzip/)\r\n\t->plan(142);\r\n\r\n$t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    server {\r\n        listen       127.0.0.1:8080 http2;\r\n        listen       127.0.0.1:8081;\r\n        server_name  localhost;\r\n\r\n        location / {\r\n            add_header X-Header X-Foo;\r\n            add_header X-Sent-Foo $http_x_foo;\r\n            add_header X-Referer $http_referer;\r\n            return 200 \'body\';\r\n        }\r\n        location /t {\r\n        }\r\n        location /gzip.html {\r\n            gzip on;\r\n            gzip_min_length 0;\r\n            gzip_vary on;\r\n            alias %%TESTDIR%%/t2.html;\r\n        }\r\n        location /frame_size {\r\n            http2_chunk_size 64k;\r\n            alias %%TESTDIR%%;\r\n            output_buffers 2 1m;\r\n        }\r\n        location /chunk_size {\r\n            http2_chunk_size 1;\r\n            return 200 \'body\';\r\n        }\r\n        location /redirect {\r\n            error_page 405 /;\r\n            return 405;\r\n        }\r\n        location /return301 {\r\n            return 301;\r\n        }\r\n        location /return301_absolute {\r\n            return 301 text;\r\n        }\r\n        location /return301_relative {\r\n            return 301 /;\r\n        }\r\n        location /charset {\r\n            charset utf-8;\r\n            return 200;\r\n        }\r\n    }\r\n\r\n    server {\r\n        listen       127.0.0.1:8082 http2;\r\n        server_name  localhost;\r\n        return 200   first;\r\n    }\r\n\r\n    server {\r\n        listen       127.0.0.1:8082 http2;\r\n        server_name  localhost2;\r\n        return 200   second;\r\n    }\r\n\r\n    server {\r\n        listen       127.0.0.1:8083 http2;\r\n        server_name  localhost;\r\n\r\n        http2_max_concurrent_streams 1;\r\n    }\r\n\r\n    server {\r\n        listen       127.0.0.1:8086 http2;\r\n        server_name  localhost;\r\n\r\n        send_timeout 1s;\r\n        lingering_close off;\r\n    }\r\n\r\n    server {\r\n        listen       127.0.0.1:8087 http2;\r\n        server_name  localhost;\r\n\r\n        client_header_timeout 1s;\r\n        client_body_timeout 1s;\r\n        lingering_close off;\r\n\r\n        location / { }\r\n\r\n        location /proxy/ {\r\n            proxy_pass http://127.0.0.1:8081/;\r\n        }\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n# suppress deprecation warning\r\n\r\nopen OLDERR, "">&"", \\*STDERR; close STDERR;\r\n$t->run();\r\nopen STDERR, "">&"", \\*OLDERR;\r\n\r\n# file size is slightly beyond initial window size: 2**16 + 80 bytes\r\n\r\n$t->write_file(\'t1.html\',\r\n\tjoin(\'\', map { sprintf ""X%04dXXX"", $_ } (1 .. 8202)));\r\n$t->write_file(\'tbig.html\',\r\n\tjoin(\'\', map { sprintf ""XX%06dXX"", $_ } (1 .. 500000)));\r\n\r\n$t->write_file(\'t2.html\', \'SEE-THIS\');\r\n\r\n###############################################################################\r\n\r\n# SETTINGS\r\n\r\nmy $s = Test::Nginx::HTTP2->new(port(8080), pure => 1);\r\nmy $frames = $s->read(all => [\r\n\t{ type => \'WINDOW_UPDATE\' },\r\n\t{ type => \'SETTINGS\'}\r\n]);\r\n\r\nmy ($frame) = grep { $_->{type} eq \'WINDOW_UPDATE\' } @$frames;\r\nok($frame, \'WINDOW_UPDATE frame\');\r\nis($frame->{flags}, 0, \'WINDOW_UPDATE zero flags\');\r\nis($frame->{sid}, 0, \'WINDOW_UPDATE zero sid\');\r\nis($frame->{length}, 4, \'WINDOW_UPDATE fixed length\');\r\n\r\n($frame) = grep { $_->{type} eq \'SETTINGS\' } @$frames;\r\nok($frame, \'SETTINGS frame\');\r\nis($frame->{flags}, 0, \'SETTINGS flags\');\r\nis($frame->{sid}, 0, \'SETTINGS stream\');\r\n\r\n$s->h2_settings(1);\r\n$s->h2_settings(0);\r\n\r\n$frames = $s->read(all => [{ type => \'SETTINGS\' }]);\r\n\r\n($frame) = grep { $_->{type} eq \'SETTINGS\' } @$frames;\r\nok($frame, \'SETTINGS frame ack\');\r\nis($frame->{flags}, 1, \'SETTINGS flags ack\');\r\n\r\n# SETTINGS - no ack on PROTOCOL_ERROR\r\n\r\n$s = Test::Nginx::HTTP2->new(port(8080), pure => 1);\r\n$frames = $s->read(all => [\r\n\t{ type => \'WINDOW_UPDATE\' },\r\n\t{ type => \'SETTINGS\'}\r\n]);\r\n\r\n$s->h2_settings(1);\r\n$s->h2_settings(0, 0x5 => 42);\r\n\r\n$frames = $s->read(all => [\r\n\t{ type => \'SETTINGS\'},\r\n\t{ type => \'GOAWAY\' }\r\n]);\r\n\r\n($frame) = grep { $_->{type} eq \'SETTINGS\' } @$frames;\r\nis($frame, undef, \'SETTINGS PROTOCOL_ERROR - no ack\');\r\n\r\n($frame) = grep { $_->{type} eq \'GOAWAY\' } @$frames;\r\nok($frame, \'SETTINGS PROTOCOL_ERROR - GOAWAY\');\r\n\r\n# PING\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$s->h2_ping(\'SEE-THIS\');\r\n$frames = $s->read(all => [{ type => \'PING\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""PING"" } @$frames;\r\nok($frame, \'PING frame\');\r\nis($frame->{value}, \'SEE-THIS\', \'PING payload\');\r\nis($frame->{flags}, 1, \'PING flags ack\');\r\nis($frame->{sid}, 0, \'PING stream\');\r\n\r\n# GOAWAY\r\n\r\nTest::Nginx::HTTP2->new()->h2_goaway(0, 0, 5);\r\nTest::Nginx::HTTP2->new()->h2_goaway(0, 0, 5, \'foobar\');\r\nTest::Nginx::HTTP2->new()->h2_goaway(0, 0, 5, \'foobar\', split => [ 8, 8, 4 ]);\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$s->h2_goaway(0, 0, 5);\r\n$s->h2_goaway(0, 0, 5);\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$s->h2_goaway(0, 0, 5, \'foobar\', len => 0);\r\n$frames = $s->read(all => [{ type => ""GOAWAY"" }]);\r\n\r\n($frame) = grep { $_->{type} eq ""GOAWAY"" } @$frames;\r\nok($frame, \'GOAWAY invalid length - GOAWAY frame\');\r\nis($frame->{code}, 6, \'GOAWAY invalid length - GOAWAY FRAME_SIZE_ERROR\');\r\n\r\n# 6.8.  GOAWAY\r\n#   An endpoint MUST treat a GOAWAY frame with a stream identifier other\r\n#   than 0x0 as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$s->h2_goaway(1, 0, 5, \'foobar\');\r\n$frames = $s->read(all => [{ type => ""GOAWAY"" }], wait => 0.5);\r\n\r\n($frame) = grep { $_->{type} eq ""GOAWAY"" } @$frames;\r\nok($frame, \'GOAWAY invalid stream - GOAWAY frame\');\r\nis($frame->{code}, 1, \'GOAWAY invalid stream - GOAWAY PROTOCOL_ERROR\');\r\n\r\n# client-initiated PUSH_PROMISE, just to ensure nothing went wrong\r\n# N.B. other implementation returns zero code, which is not anyhow regulated\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n{\r\n\tlocal $SIG{PIPE} = \'IGNORE\';\r\n\tsyswrite($s->{socket}, pack(""x2C2xN"", 4, 0x5, 1));\r\n}\r\n$frames = $s->read(all => [{ type => ""GOAWAY"" }]);\r\n\r\n($frame) = grep { $_->{type} eq ""GOAWAY"" } @$frames;\r\nok($frame, \'client-initiated PUSH_PROMISE - GOAWAY frame\');\r\nis($frame->{code}, 1, \'client-initiated PUSH_PROMISE - GOAWAY PROTOCOL_ERROR\');\r\n\r\n# GET\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\nmy $sid = $s->new_stream();\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nok($frame, \'HEADERS frame\');\r\nis($frame->{sid}, $sid, \'HEADERS stream\');\r\nis($frame->{headers}->{\':status\'}, 200, \'HEADERS status\');\r\nis($frame->{headers}->{\'x-header\'}, \'X-Foo\', \'HEADERS header\');\r\n\r\n($frame) = grep { $_->{type} eq ""DATA"" } @$frames;\r\nok($frame, \'DATA frame\');\r\nis($frame->{length}, length \'body\', \'DATA length\');\r\nis($frame->{data}, \'body\', \'DATA payload\');\r\n\r\n# GET in the new stream on same connection\r\n\r\n$sid = $s->new_stream();\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{sid}, $sid, \'HEADERS stream 2\');\r\nis($frame->{headers}->{\':status\'}, 200, \'HEADERS status 2\');\r\nis($frame->{headers}->{\'x-header\'}, \'X-Foo\', \'HEADERS header 2\');\r\n\r\n($frame) = grep { $_->{type} eq ""DATA"" } @$frames;\r\nok($frame, \'DATA frame 2\');\r\nis($frame->{sid}, $sid, \'HEADERS stream 2\');\r\nis($frame->{length}, length \'body\', \'DATA length 2\');\r\nis($frame->{data}, \'body\', \'DATA payload 2\');\r\n\r\n# HEAD\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ method => \'HEAD\' });\r\n$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{sid}, $sid, \'HEAD - HEADERS\');\r\nis($frame->{headers}->{\':status\'}, 200, \'HEAD - HEADERS status\');\r\nis($frame->{headers}->{\'x-header\'}, \'X-Foo\', \'HEAD - HEADERS header\');\r\n\r\n($frame) = grep { $_->{type} eq ""DATA"" } @$frames;\r\nis($frame, undef, \'HEAD - no body\');\r\n\r\n# CONNECT\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ method => \'CONNECT\' });\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 405, \'CONNECT - not allowed\');\r\n\r\n# TRACE\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ method => \'TRACE\' });\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200, \'TRACE - allowed\');\r\n\r\n# range filter\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\', mode => 0 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/t1.html\', mode => 1 },\r\n\t{ name => \':authority\', value => \'localhost\', mode => 1 },\r\n\t{ name => \'range\', value => \'bytes=10-19\', mode => 1 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 206, \'range - HEADERS status\');\r\n\r\n($frame) = grep { $_->{type} eq ""DATA"" } @$frames;\r\nis($frame->{length}, 10, \'range - DATA length\');\r\nis($frame->{data}, \'002XXXX000\', \'range - DATA payload\');\r\n\r\n# http2_chunk_size=1\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/chunk_size\' });\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\nmy @data = grep { $_->{type} eq ""DATA"" } @$frames;\r\nis(@data, 4, \'chunk_size frames\');\r\nis(join(\' \', map { $_->{data} } @data), \'b o d y\', \'chunk_size data\');\r\nis(join(\' \', map { $_->{flags} } @data), \'0 0 0 1\', \'chunk_size flags\');\r\n\r\n# CONTINUATION\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ continuation => 1, headers => [\r\n\t{ name => \':method\', value => \'HEAD\', mode => 1 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/\', mode => 0 },\r\n\t{ name => \':authority\', value => \'localhost\', mode => 1 }]});\r\n$s->h2_continue($sid, { continuation => 1, headers => [\r\n\t{ name => \'x-foo\', value => \'X-Bar\', mode => 2 }]});\r\n$s->h2_continue($sid, { headers => [\r\n\t{ name => \'referer\', value => \'foo\', mode => 2 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""DATA"" } @$frames;\r\nis($frame, undef, \'CONTINUATION - fragment 1\');\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\'x-sent-foo\'}, \'X-Bar\', \'CONTINUATION - fragment 2\');\r\nis($frame->{headers}->{\'x-referer\'}, \'foo\', \'CONTINUATION - fragment 3\');\r\n\r\n# CONTINUATION - in the middle of request header field\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ continuation => [ 2, 4, 1, 5 ], headers => [\r\n\t{ name => \':method\', value => \'HEAD\', mode => 1 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/\', mode => 0 },\r\n\t{ name => \':authority\', value => \'localhost\', mode => 1 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200, \'CONTINUATION - in header field\');\r\n\r\n# CONTINUATION on a closed stream\r\n\r\n$s->h2_continue(1, { headers => [\r\n\t{ name => \'x-foo\', value => \'X-Bar\', mode => 2 }]});\r\n$frames = $s->read(all => [{ sid => 1, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""GOAWAY"" } @$frames;\r\nis($frame->{type}, \'GOAWAY\', \'GOAWAY - CONTINUATION closed stream\');\r\nis($frame->{code}, 1, \'GOAWAY - CONTINUATION closed stream - PROTOCOL_ERROR\');\r\n\r\n# frame padding\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ padding => 42, headers => [\r\n\t{ name => \':method\', value => \'GET\', mode => 0 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/\', mode => 0 },\r\n\t{ name => \':authority\', value => \'localhost\', mode => 1 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200, \'padding - HEADERS status\');\r\n\r\n$sid = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\', mode => 0 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/\', mode => 0 },\r\n\t{ name => \':authority\', value => \'localhost\', mode => 1 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200, \'padding - next stream\');\r\n\r\n# padding followed by CONTINUATION\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ padding => 42, continuation => [ 2, 4, 1, 5 ],\r\n\theaders => [\r\n\t{ name => \':method\', value => \'GET\', mode => 1 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/\', mode => 0 },\r\n\t{ name => \':authority\', value => \'localhost\', mode => 1 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200, \'padding - CONTINUATION\');\r\n\r\n# internal redirect\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/redirect\' });\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 405, \'redirect - HEADERS\');\r\n\r\n($frame) = grep { $_->{type} eq ""DATA"" } @$frames;\r\nok($frame, \'redirect - DATA\');\r\nis($frame->{data}, \'body\', \'redirect - DATA payload\');\r\n\r\n# return 301 with absolute URI\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/return301_absolute\' });\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 301, \'return 301 absolute - status\');\r\nis($frame->{headers}->{\'location\'}, \'text\', \'return 301 absolute - location\');\r\n\r\n# return 301 with relative URI\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/return301_relative\' });\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 301, \'return 301 relative - status\');\r\nis($frame->{headers}->{\'location\'}, \'http://localhost:\' . port(8080) . \'/\',\r\n\t\'return 301 relative - location\');\r\n\r\n# return 301 with relative URI and \':authority\' request header field\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\', mode => 0 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/return301_relative\', mode => 2 },\r\n\t{ name => \':authority\', value => \'localhost\', mode => 2 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 301,\r\n\t\'return 301 relative - authority - status\');\r\nis($frame->{headers}->{\'location\'}, \'http://localhost:\' . port(8080) . \'/\',\r\n\t\'return 301 relative - authority - location\');\r\n\r\n# return 301 with relative URI and \'host\' request header field\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\', mode => 0 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/return301_relative\', mode => 2 },\r\n\t{ name => \'host\', value => \'localhost\', mode => 2 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 301,\r\n\t\'return 301 relative - host - status\');\r\nis($frame->{headers}->{\'location\'}, \'http://localhost:\' . port(8080) . \'/\',\r\n\t\'return 301 relative - host - location\');\r\n\r\n# virtual host\r\n\r\n$s = Test::Nginx::HTTP2->new(port(8082));\r\n$sid = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\', mode => 0 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/\', mode => 0 },\r\n\t{ name => \'host\', value => \'localhost\', mode => 2 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200,\r\n\t\'virtual host - host - status\');\r\n\r\n($frame) = grep { $_->{type} eq ""DATA"" } @$frames;\r\nis($frame->{data}, \'first\', \'virtual host - host - DATA\');\r\n\r\n$sid = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\', mode => 0 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/\', mode => 0 },\r\n\t{ name => \':authority\', value => \'localhost\', mode => 2 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200,\r\n\t\'virtual host - authority - status\');\r\n\r\n($frame) = grep { $_->{type} eq ""DATA"" } @$frames;\r\nis($frame->{data}, \'first\', \'virtual host - authority - DATA\');\r\n\r\n# virtual host - second\r\n\r\n$sid = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\', mode => 0 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/\', mode => 0 },\r\n\t{ name => \'host\', value => \'localhost2\', mode => 2 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200,\r\n\t\'virtual host 2 - host - status\');\r\n\r\n($frame) = grep { $_->{type} eq ""DATA"" } @$frames;\r\nis($frame->{data}, \'second\', \'virtual host 2 - host - DATA\');\r\n\r\n$sid = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\', mode => 0 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/\', mode => 0 },\r\n\t{ name => \':authority\', value => \'localhost2\', mode => 2 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200,\r\n\t\'virtual host 2 - authority - status\');\r\n\r\n($frame) = grep { $_->{type} eq ""DATA"" } @$frames;\r\nis($frame->{data}, \'second\', \'virtual host 2 - authority - DATA\');\r\n\r\n# gzip tests for internal nginx version\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\', mode => 0 },\r\n\t{ name => \':scheme\', value => \'http\', mode => 0 },\r\n\t{ name => \':path\', value => \'/gzip.html\' },\r\n\t{ name => \':authority\', value => \'localhost\', mode => 1 },\r\n\t{ name => \'accept-encoding\', value => \'gzip\' }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\'content-encoding\'}, \'gzip\', \'gzip - encoding\');\r\nis($frame->{headers}->{\'vary\'}, \'Accept-Encoding\', \'gzip - vary\');\r\n\r\n($frame) = grep { $_->{type} eq ""DATA"" } @$frames;\r\ngunzip_like($frame->{data}, qr/^SEE-THIS\\Z/, \'gzip - DATA\');\r\n\r\n# charset\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/charset\' });\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\'content-type\'}, \'text/plain; charset=utf-8\', \'charset\');\r\n\r\n# partial request header frame received (field split),\r\n# the rest of frame is received after client header timeout\r\n\r\n$s = Test::Nginx::HTTP2->new(port(8087));\r\n$sid = $s->new_stream({ path => \'/t2.html\', split => [35],\r\n\tsplit_delay => 2.1 });\r\n$frames = $s->read(all => [{ type => \'RST_STREAM\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""RST_STREAM"" } @$frames;\r\nok($frame, \'client header timeout\');\r\nis($frame->{code}, 1, \'client header timeout - protocol error\');\r\n\r\n$s->h2_ping(\'SEE-THIS\');\r\n$frames = $s->read(all => [{ type => \'PING\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""PING"" && $_->{flags} & 0x1 } @$frames;\r\nok($frame, \'client header timeout - PING\');\r\n\r\n# partial request header frame received (no field split),\r\n# the rest of frame is received after client header timeout\r\n\r\n$s = Test::Nginx::HTTP2->new(port(8087));\r\n$sid = $s->new_stream({ path => \'/t2.html\', split => [20], split_delay => 2.1 });\r\n$frames = $s->read(all => [{ type => \'RST_STREAM\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""RST_STREAM"" } @$frames;\r\nok($frame, \'client header timeout 2\');\r\nis($frame->{code}, 1, \'client header timeout 2 - protocol error\');\r\n\r\n$s->h2_ping(\'SEE-THIS\');\r\n$frames = $s->read(all => [{ type => \'PING\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""PING"" && $_->{flags} & 0x1 } @$frames;\r\nok($frame, \'client header timeout 2 - PING\');\r\n\r\n# partial request body data frame received, the rest is after body timeout\r\n\r\n$s = Test::Nginx::HTTP2->new(port(8087));\r\n$sid = $s->new_stream({ path => \'/proxy/t2.html\', body_more => 1 });\r\n$s->h2_body(\'TEST\', { split => [10], split_delay => 2.1 });\r\n$frames = $s->read(all => [{ type => \'RST_STREAM\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""RST_STREAM"" } @$frames;\r\nok($frame, \'client body timeout\');\r\nis($frame->{code}, 1, \'client body timeout - protocol error\');\r\n\r\n$s->h2_ping(\'SEE-THIS\');\r\n$frames = $s->read(all => [{ type => \'PING\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""PING"" && $_->{flags} & 0x1 } @$frames;\r\nok($frame, \'client body timeout - PING\');\r\n\r\n# partial request body data frame with connection close after body timeout\r\n\r\n$s = Test::Nginx::HTTP2->new(port(8087));\r\n$sid = $s->new_stream({ path => \'/proxy/t2.html\', body_more => 1 });\r\n$s->h2_body(\'TEST\', { split => [ 12 ], abort => 1 });\r\n\r\nselect undef, undef, undef, 1.1;\r\nundef $s;\r\n\r\n# proxied request with logging pristine request header field (e.g., referer)\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\' },\r\n\t{ name => \':scheme\', value => \'http\' },\r\n\t{ name => \':path\', value => \'/proxy2/\' },\r\n\t{ name => \':authority\', value => \'localhost\' },\r\n\t{ name => \'referer\', value => \'foo\' }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200, \'proxy with logging request headers\');\r\n\r\n$sid = $s->new_stream();\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nok($frame->{headers}, \'proxy with logging request headers - next\');\r\n\r\n# initial window size, client side\r\n\r\n# 6.9.2.  Initial Flow-Control Window Size\r\n#   When an HTTP/2 connection is first established, new streams are\r\n#   created with an initial flow-control window size of 65,535 octets.\r\n#   The connection flow-control window is also 65,535 octets.\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/t1.html\' });\r\n$frames = $s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);\r\n\r\n# with the default http2_chunk_size, data is divided into 8 data frames\r\n\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\nmy $lengths = join \' \', map { $_->{length} } @data;\r\nis($lengths, \'8192 8192 8192 8192 8192 8192 8192 8191\',\r\n\t\'iws - stream blocked on initial window size\');\r\n\r\n$s->h2_ping(\'SEE-THIS\');\r\n$frames = $s->read(all => [{ type => \'PING\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""PING"" && $_->{flags} & 0x1 } @$frames;\r\nok($frame, \'iws - PING not blocked\');\r\n\r\n$s->h2_window(2**16, $sid);\r\n$frames = $s->read(wait => 0.2);\r\nis(@$frames, 0, \'iws - updated stream window\');\r\n\r\n$s->h2_window(2**16);\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\nmy $sum = eval join \'+\', map { $_->{length} } @data;\r\nis($sum, 81, \'iws - updated connection window\');\r\n\r\n# SETTINGS (initial window size, client side)\r\n\r\n# 6.9.2.  Initial Flow-Control Window Size\r\n#   Both endpoints can adjust the initial window size for new streams by\r\n#   including a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS\r\n#   frame that forms part of the connection preface.  The connection\r\n#   flow-control window can only be changed using WINDOW_UPDATE frames.\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$s->h2_settings(0, 0x4 => 2**17);\r\n$s->h2_window(2**17);\r\n\r\n$sid = $s->new_stream({ path => \'/t1.html\' });\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\n$sum = eval join \'+\', map { $_->{length} } @data;\r\nis($sum, 2**16 + 80, \'iws - increased\');\r\n\r\n# INITIAL_WINDOW_SIZE duplicate settings\r\n\r\n# 6.5.  SETTINGS\r\n#   Each parameter in a SETTINGS frame replaces any existing value for\r\n#   that parameter.  Parameters are processed in the order in which they\r\n#   appear, and a receiver of a SETTINGS frame does not need to maintain\r\n#   any state other than the current value of its parameters.  Therefore,\r\n#   the value of a SETTINGS parameter is the last value that is seen by a\r\n#   receiver.\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$s->h2_window(2**17);\r\n\r\n$sid = $s->new_stream({ path => \'/t1.html\' });\r\n\r\n$frames = $s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\n$sum = eval join \'+\', map { $_->{length} } @data;\r\nis($sum, 2**16 - 1, \'iws duplicate - default stream window\');\r\n\r\n# this should effect in extra stream window octect\r\n# $s->h2_settings(0, 0x4 => 42, 0x4 => 2**16);\r\n{\r\n\tlocal $SIG{PIPE} = \'IGNORE\';\r\n\tsyswrite($s->{socket}, pack(""x2C2x5nNnN"", 12, 0x4, 4, 42, 4, 2**16));\r\n}\r\n\r\n$frames = $s->read(all => [{ sid => $sid, length => 1 }]);\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\n$sum = eval join \'+\', map { $_->{length} } @data;\r\nis($sum, 1, \'iws duplicate - updated stream window\');\r\n\r\n# yet more octets to finish receiving the response\r\n\r\n$s->h2_settings(0, 0x4 => 2**16 + 80);\r\n\r\n$frames = $s->read(all => [{ sid => $sid, length => 80 }]);\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\n$sum = eval join \'+\', map { $_->{length} } @data;\r\nis($sum, 80, \'iws duplicate - updated stream window 2\');\r\n\r\n# probe for negative available space in a flow control window\r\n\r\n# 6.9.2.  Initial Flow-Control Window Size\r\n#   A change to SETTINGS_INITIAL_WINDOW_SIZE can cause the available\r\n#   space in a flow-control window to become negative.  A sender MUST\r\n#   track the negative flow-control window and MUST NOT send new flow-\r\n#   controlled frames until it receives WINDOW_UPDATE frames that cause\r\n#   the flow-control window to become positive.\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/t1.html\' });\r\n$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);\r\n\r\n$s->h2_window(1);\r\n$s->h2_settings(0, 0x4 => 42);\r\n$s->h2_window(1024, $sid);\r\n\r\n$frames = $s->read(all => [{ type => \'SETTINGS\' }]);\r\n\r\n($frame) = grep { $_->{type} eq \'SETTINGS\' } @$frames;\r\nok($frame, \'negative window - SETTINGS frame ack\');\r\nis($frame->{flags}, 1, \'negative window - SETTINGS flags ack\');\r\n\r\n($frame) = grep { $_->{type} ne \'SETTINGS\' } @$frames;\r\nis($frame, undef, \'negative window - no data\');\r\n\r\n# predefined window size, minus new iws settings, minus window update\r\n\r\n$s->h2_window(2**16 - 1 - 42 - 1024, $sid);\r\n\r\n$frames = $s->read(wait => 0.2);\r\nis(@$frames, 0, \'zero window - no data\');\r\n\r\n$s->h2_window(1, $sid);\r\n\r\n$frames = $s->read(all => [{ sid => $sid, length => 1 }]);\r\nis(@$frames, 1, \'positive window\');\r\n\r\nSKIP: {\r\nskip \'failed connection\', 2 unless @$frames;\r\n\r\nis(@$frames[0]->{type}, \'DATA\', \'positive window - data\');\r\nis(@$frames[0]->{length}, 1, \'positive window - data length\');\r\n\r\n}\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$s->h2_window(2**30);\r\n$s->h2_settings(0, 0x4 => 2**30);\r\n\r\n$sid = $s->new_stream({ path => \'/frame_size/tbig.html\' });\r\n\r\nsleep 1;\r\n$s->h2_settings(0, 0x5 => 2**15);\r\n\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n$lengths = join \' \', map { $_->{length} } @$frames;\r\nunlike($lengths, qr/16384 0 16384/, \'SETTINGS ack after queued DATA\');\r\n\r\n# ask write handler in sending large response\r\n\r\nSKIP: {\r\nskip \'unsafe socket tests\', 4 unless $ENV{TEST_NGINX_UNSAFE};\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/tbig.html\' });\r\n\r\n$s->h2_window(2**30, $sid);\r\n$s->h2_window(2**30);\r\n\r\nsleep 1;\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200, \'large response - HEADERS\');\r\n\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\n$sum = eval join \'+\', map { $_->{length} } @data;\r\nis($sum, 5000000, \'large response - DATA\');\r\n\r\n# Make sure http2 write handler doesn\'t break a connection.\r\n\r\n$sid = $s->new_stream();\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200, \'new stream after large response\');\r\n\r\n# write event send timeout\r\n\r\n$s = Test::Nginx::HTTP2->new(port(8086));\r\n$sid = $s->new_stream({ path => \'/tbig.html\' });\r\n$s->h2_window(2**30, $sid);\r\n$s->h2_window(2**30);\r\n\r\nselect undef, undef, undef, 2.1;\r\n\r\n$s->h2_ping(\'SEE-THIS\');\r\n\r\n$frames = $s->read(all => [{ type => \'PING\' }]);\r\nok(!grep ({ $_->{type} eq ""PING"" } @$frames), \'large response - send timeout\');\r\n\r\n}\r\n\r\n# SETTINGS_MAX_FRAME_SIZE\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/frame_size/t1.html\' });\r\n$s->h2_window(2**18, 1);\r\n$s->h2_window(2**18);\r\n\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\nis($data[0]->{length}, 2**14, \'max frame size - default\');\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$s->h2_settings(0, 0x5 => 2**15);\r\n$sid = $s->new_stream({ path => \'/frame_size/t1.html\' });\r\n$s->h2_window(2**18, 1);\r\n$s->h2_window(2**18);\r\n\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\nis($data[0]->{length}, 2**15, \'max frame size - custom\');\r\n\r\n# SETTINGS_INITIAL_WINDOW_SIZE + SETTINGS_MAX_FRAME_SIZE\r\n# Expanding available stream window should not result in emitting\r\n# new frames before remaining SETTINGS parameters were applied.\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$s->h2_window(2**17);\r\n$s->h2_settings(0, 0x4 => 42);\r\n\r\n$sid = $s->new_stream({ path => \'/frame_size/t1.html\' });\r\n$s->read(all => [{ sid => $sid, length => 42 }]);\r\n\r\n$s->h2_settings(0, 0x4 => 2**17, 0x5 => 2**15);\r\n\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\n$lengths = join \' \', map { $_->{length} } @data;\r\nis($lengths, \'32768 32768 38\', \'multiple SETTINGS\');\r\n\r\n# stream multiplexing + WINDOW_UPDATE\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/t1.html\' });\r\n$frames = $s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);\r\n\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\n$sum = eval join \'+\', map { $_->{length} } @data;\r\nis($sum, 2**16 - 1, \'multiple - stream1 data\');\r\n\r\nmy $sid2 = $s->new_stream({ path => \'/t1.html\' });\r\n$frames = $s->read(all => [{ sid => $sid2, fin => 0x4 }]);\r\n\r\n@data = grep { $_->{type} eq ""DATA"" } @$frames;\r\nis(@data, 0, \'multiple - stream2 no data\');\r\n\r\n$s->h2_window(2**17, $sid);\r\n$s->h2_window(2**17, $sid2);\r\n$s->h2_window(2**17);\r\n\r\n$frames = $s->read(all => [\r\n\t{ sid => $sid, fin => 1 },\r\n\t{ sid => $sid2, fin => 1 }\r\n]);\r\n\r\n@data = grep { $_->{type} eq ""DATA"" && $_->{sid} == $sid } @$frames;\r\n$sum = eval join \'+\', map { $_->{length} } @data;\r\nis($sum, 81, \'multiple - stream1 remain data\');\r\n\r\n@data = grep { $_->{type} eq ""DATA"" && $_->{sid} == $sid2 } @$frames;\r\n$sum = eval join \'+\', map { $_->{length} } @data;\r\nis($sum, 2**16 + 80, \'multiple - stream2 full data\');\r\n\r\n# http2_max_concurrent_streams\r\n\r\n$s = Test::Nginx::HTTP2->new(port(8083), pure => 1);\r\n$frames = $s->read(all => [{ type => \'SETTINGS\' }]);\r\n\r\n($frame) = grep { $_->{type} eq \'SETTINGS\' } @$frames;\r\nis($frame->{3}, 1, \'http2_max_concurrent_streams SETTINGS\');\r\n\r\n$s->h2_window(2**18);\r\n\r\n$sid = $s->new_stream({ path => \'/t1.html\' });\r\n$frames = $s->read(all => [{ sid => $sid, length => 2 ** 16 - 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" && $_->{sid} == $sid } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200, \'http2_max_concurrent_streams\');\r\n\r\n$sid2 = $s->new_stream({ path => \'/t1.html\' });\r\n$frames = $s->read(all => [{ type => \'RST_STREAM\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" && $_->{sid} == $sid2 } @$frames;\r\nisnt($frame->{headers}->{\':status\'}, 200, \'http2_max_concurrent_streams 2\');\r\n\r\n($frame) = grep { $_->{type} eq ""RST_STREAM"" && $_->{sid} == $sid2 } @$frames;\r\nis($frame->{sid}, $sid2, \'http2_max_concurrent_streams RST_STREAM sid\');\r\nis($frame->{length}, 4, \'http2_max_concurrent_streams RST_STREAM length\');\r\nis($frame->{flags}, 0, \'http2_max_concurrent_streams RST_STREAM flags\');\r\nis($frame->{code}, 7, \'http2_max_concurrent_streams RST_STREAM code\');\r\n\r\n# properly skip header field that\'s not/never indexed from discarded streams\r\n\r\n$sid2 = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\' },\r\n\t{ name => \':scheme\', value => \'http\' },\r\n\t{ name => \':path\', value => \'/\', mode => 6 },\r\n\t{ name => \':authority\', value => \'localhost\' },\r\n\t{ name => \'x-foo\', value => \'Foo\', mode => 2 }]});\r\n$frames = $s->read(all => [{ type => \'RST_STREAM\' }]);\r\n\r\n# also if split across writes\r\n\r\n$sid2 = $s->new_stream({ split => [ 22 ], headers => [\r\n\t{ name => \':method\', value => \'GET\' },\r\n\t{ name => \':scheme\', value => \'http\' },\r\n\t{ name => \':path\', value => \'/\', mode => 6 },\r\n\t{ name => \':authority\', value => \'localhost\' },\r\n\t{ name => \'x-bar\', value => \'Bar\', mode => 2 }]});\r\n$frames = $s->read(all => [{ type => \'RST_STREAM\' }]);\r\n\r\n# also if split across frames\r\n\r\n$sid2 = $s->new_stream({ continuation => [ 17 ], headers => [\r\n\t{ name => \':method\', value => \'GET\' },\r\n\t{ name => \':scheme\', value => \'http\' },\r\n\t{ name => \':path\', value => \'/\', mode => 6 },\r\n\t{ name => \':authority\', value => \'localhost\' },\r\n\t{ name => \'x-baz\', value => \'Baz\', mode => 2 }]});\r\n$frames = $s->read(all => [{ type => \'RST_STREAM\' }]);\r\n\r\n$s->h2_window(2**16, $sid);\r\n$s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n$sid = $s->new_stream({ headers => [\r\n\t{ name => \':method\', value => \'GET\' },\r\n\t{ name => \':scheme\', value => \'http\' },\r\n\t{ name => \':path\', value => \'/t2.html\' },\r\n\t{ name => \':authority\', value => \'localhost\' },\r\n# make sure that discarded streams updated dynamic table\r\n\t{ name => \'x-foo\', value => \'Foo\', mode => 0 },\r\n\t{ name => \'x-bar\', value => \'Bar\', mode => 0 },\r\n\t{ name => \'x-baz\', value => \'Baz\', mode => 0 }]});\r\n$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n($frame) = grep { $_->{type} eq ""HEADERS"" && $_->{sid} == $sid } @$frames;\r\nis($frame->{headers}->{\':status\'}, 200, \'http2_max_concurrent_streams 3\');\r\n\r\n\r\n# some invalid cases below\r\n\r\n# invalid connection preface\r\n\r\nTODO: {\r\nlocal $TODO = \'not yet\' unless $t->has_version(\'1.25.1\');\r\n\r\nlike(http(\'x\' x 16), qr/400 Bad Request/, \'invalid preface\');\r\nlike(http(\'PRI * HTTP/2.0\' . CRLF . CRLF . \'x\' x 8), qr/400 Bad Request/,\r\n\t\'invalid preface 2\');\r\n\r\n}\r\n\r\n# GOAWAY on SYN_STREAM with even StreamID\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$s->new_stream({ path => \'/\' }, 2);\r\n$frames = $s->read(all => [{ type => \'GOAWAY\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""GOAWAY"" } @$frames;\r\nok($frame, \'even stream - GOAWAY frame\');\r\nis($frame->{code}, 1, \'even stream - error code\');\r\nis($frame->{last_sid}, 0, \'even stream - last stream\');\r\n\r\n# GOAWAY on SYN_STREAM with backward StreamID\r\n\r\n# 5.1.1.  Stream Identifiers\r\n#   The first use of a new stream identifier implicitly closes all\r\n#   streams in the ""idle"" state <..> with a lower-valued stream identifier.\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/\' }, 3);\r\n$s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n$sid2 = $s->new_stream({ path => \'/\' }, 1);\r\n$frames = $s->read(all => [{ type => \'GOAWAY\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""GOAWAY"" } @$frames;\r\nok($frame, \'backward stream - GOAWAY frame\');\r\nis($frame->{code}, 1, \'backward stream - error code\');\r\nis($frame->{last_sid}, $sid, \'backward stream - last stream\');\r\n\r\n# GOAWAY on the second SYN_STREAM with same StreamID\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$sid = $s->new_stream({ path => \'/\' });\r\n$s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\n$sid2 = $s->new_stream({ path => \'/\' }, $sid);\r\n$frames = $s->read(all => [{ type => \'GOAWAY\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""GOAWAY"" } @$frames;\r\nok($frame, \'dup stream - GOAWAY frame\');\r\nis($frame->{code}, 1, \'dup stream - error code\');\r\nis($frame->{last_sid}, $sid, \'dup stream - last stream\');\r\n\r\n# aborted stream with zero HEADERS payload followed by client connection close\r\n\r\nTest::Nginx::HTTP2->new()->new_stream({ split => [ 9 ], abort => 1 });\r\n\r\n# unknown frame type\r\n\r\n$s = Test::Nginx::HTTP2->new();\r\n$s->h2_unknown(\'payload\');\r\n$s->h2_ping(\'SEE-THIS\');\r\n$frames = $s->read(all => [{ type => \'PING\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""PING"" } @$frames;\r\nis($frame->{value}, \'SEE-THIS\', \'unknown frame type\');\r\n\r\n# graceful shutdown with stream waiting on HEADERS payload\r\n\r\nmy $grace = Test::Nginx::HTTP2->new(port(8087));\r\n$grace->new_stream({ split => [ 9 ], abort => 1 });\r\n\r\n# graceful shutdown waiting on incomplete request body DATA frames\r\n\r\nmy $grace3 = Test::Nginx::HTTP2->new(port(8087));\r\n$sid = $grace3->new_stream({ path => \'/proxy/t2.html\', body_more => 1 });\r\n$grace3->h2_body(\'TEST\', { body_more => 1 });\r\n\r\n# GOAWAY without awaiting active streams, further streams ignored\r\n\r\n$s = Test::Nginx::HTTP2->new(port(8080));\r\n$sid = $s->new_stream({ path => \'/t1.html\' });\r\n$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);\r\n\r\n$t->reload();\r\n\r\n$frames = $s->read(all => [{ type => \'GOAWAY\' }]);\r\n\r\n($frame) = grep { $_->{type} eq ""GOAWAY"" } @$frames;\r\nis($frame->{last_sid}, $sid, \'GOAWAY with active stream - last sid\');\r\n\r\n$sid2 = $s->new_stream();\r\n$frames = $s->read(all => [{ sid => $sid2, fin => 0x4 }], wait => 0.5);\r\n\r\n($frame) = grep { $_->{type} eq \'HEADERS\' } @$frames;\r\nis($frame, undef, \'GOAWAY with active stream - no new stream\');\r\n\r\n$s->h2_window(100, $sid);\r\n$s->h2_window(100);\r\n$frames = $s->read(all => [{ sid => $sid, fin => 0x1 }]);\r\n\r\n@data = grep { $_->{type} eq ""DATA"" && $_->{sid} == $sid } @$frames;\r\n$sum = eval join \'+\', map { $_->{length} } @data;\r\nis($sum, 81, \'GOAWAY with active stream - active stream DATA after GOAWAY\');\r\n\r\n# GOAWAY - force closing a connection by server with idle or active streams\r\n\r\n$s = Test::Nginx::HTTP2->new(port(8086));\r\n$sid = $s->new_stream();\r\n$s->read(all => [{ sid => $sid, fin => 1 }]);\r\n\r\nmy $active = Test::Nginx::HTTP2->new(port(8086));\r\n$sid = $active->new_stream({ path => \'/t1.html\' });\r\n$active->read(all => [{ sid => $sid, length => 2**16 - 1 }]);\r\n\r\n$t->stop();\r\n\r\n$frames = $s->read(all => [{ type => \'GOAWAY\' }]);\r\n($frame) = grep { $_->{type} eq ""GOAWAY"" } @$frames;\r\nok($frame, \'GOAWAY on connection close - idle stream\');\r\n\r\n$frames = $active->read(all => [{ type => \'GOAWAY\' }]);\r\n($frame) = grep { $_->{type} eq ""GOAWAY"" } @$frames;\r\nok($frame, \'GOAWAY on connection close - active stream\');\r\n\r\n###############################################################################\r\n\r\nsub gunzip_like {\r\n\tmy ($in, $re, $name) = @_;\r\n\r\n\tSKIP: {\r\n\t\teval { require IO::Uncompress::Gunzip; };\r\n\t\tTest::More::skip(\r\n\t\t\t""IO::Uncompress::Gunzip not installed"", 1) if $@;\r\n\r\n\t\tmy $out;\r\n\r\n\t\tIO::Uncompress::Gunzip::gunzip(\\$in => \\$out);\r\n\r\n\t\tlike($out, $re, $name);\r\n\t}\r\n}\r\n\r\n###############################################################################\r\n'","b'diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c\r\nindex e6e6a34..fa29a0c 100644\r\n--- a/src/http/ngx_http_request.c\r\n+++ b/src/http/ngx_http_request.c\r\n@@ -4195,60 +4195,5 @@ ngx_http_process_from(ngx_http_request_t *r, ngx_table_elt_t *h,\r\n static ngx_int_t\r\n ngx_http_trace_handler(ngx_http_request_t *r)\r\n {\r\n-    ngx_list_part_t *part;\r\n-    ngx_table_elt_t *header;\r\n-    ngx_buf_t *b;\r\n-    ngx_chain_t out;\r\n-    ngx_int_t rc, content_len;\r\n-\r\n-    b = ngx_create_temp_buf(r->pool, 200);\r\n-    if (b == NULL) {\r\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\r\n-    }\r\n-\r\n-    b->last = ngx_copy(b->last, r->request_line.data, r->request_line.len);\r\n-    *b->last++ = \'\\n\';\r\n-\r\n-    content_len = r->request_line.len + 1;\r\n-\r\n-    part = &r->headers_in.headers.part;\r\n-    header = part->elts;\r\n-    for (ngx_uint_t i = 0; ; i++) {\r\n-        if (i >= part->nelts) {\r\n-            if (part->next == NULL) {\r\n-                b->last_buf = 1;\r\n-                break;\r\n-            }\r\n-            part = part->next;\r\n-            header = part->elts;\r\n-            i = 0;\r\n-        }\r\n-\r\n-        size_t header_len = header[i].key.len + header[i].value.len + 3;\r\n-        content_len += header_len;\r\n-\r\n-        b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);\r\n-        *b->last++ = \':\';\r\n-        *b->last++ = \' \';\r\n-        b->last = ngx_copy(b->last, header[i].value.data, header[i].value.len);\r\n-        *b->last++ = \'\\n\';\r\n-    }\r\n-\r\n-    ngx_str_t ct = ngx_string(""message/http"");\r\n-    r->headers_out.status = NGX_HTTP_OK;\r\n-    r->headers_out.content_type = ct;\r\n-    r->headers_out.content_length_n = content_len;\r\n-    rc = ngx_http_send_header(r);\r\n-\r\n-    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\r\n-        return rc;\r\n-    }\r\n-\r\n-    out.buf = b;\r\n-    out.next = NULL;\r\n-\r\n-    rc = ngx_http_output_filter(r, &out);\r\n-    ngx_http_close_request(r, rc);\r\n-\r\n-    return NGX_DONE;\r\n+    return NGX_ERROR;\r\n }\r\n'","b""diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c\r\nindex e6e6a34..a5d1810 100644\r\n--- a/src/http/ngx_http_request.c\r\n+++ b/src/http/ngx_http_request.c\r\n@@ -4227,6 +4227,11 @@ ngx_http_trace_handler(ngx_http_request_t *r)\r\n         size_t header_len = header[i].key.len + header[i].value.len + 3;\r\n         content_len += header_len;\r\n \r\n+        if(content_len > 200) {\r\n+            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\r\n+            return NGX_ERROR;\r\n+        }\r\n+\r\n         b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);\r\n         *b->last++ = ':';\r\n         *b->last++ = ' ';\r\n""",b'TRACE / HTTP/1.1\r\nHost: localhost\r\nHeaderA: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderB: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderC: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderD: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderE: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderF: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderG: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderH: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderI: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderJ: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderK: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderL: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderM: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderN: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderO: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderP: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderQ: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderR: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderS: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderT: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderU: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderV: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderW: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderX: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderY: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\nHeaderZ: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\n\r\n'
cpv4,"b""# Overview\r\nID: cpv4    \r\nType: [CWE-122](https://cwe.mitre.org/data/definitions/122.html) Heap buffer overflow    \r\nSanitizer: AddressSanitizer: heap-buffer-overflow    \r\n\r\n# Details\r\n\r\nNginx is able to serve dynamic and [static](https://docs.nginx.com/nginx/admin-guide/web-server/serving-static-content/) content. Additionally, nginx also allows for user agent specific content and sets flags based upon specific browser types. For browsers identified as Safari, the function not only sets a cookie but also customizes the cookie's value to include the request's ``last_modified_time`` and ``content_length``, appended with the existing cookie value. The safari flag is set [here](https://github.com/nginx/nginx/blob/master/src/http/ngx_http_request.c#L1949). An additional comment was added that discusses Safari's non-compliance with certain aspects of RFC 2109 regarding cookies to test how comments can affect LLM interpretations. There is a known wierdness in the [past](https://discussions.apple.com/thread/4078916?sortBy=best).\r\n\r\nThe inject modifies the ``ngx_http_static_handler`` function to invoke a new function, ``ngx_http_set_browser_cookie``. The function checks the ``headers_in`` structure to determine if the request originates from Safari, MSIE, or Chrome. If none of these conditions are met, it simply returns NGX\\_OK, skipping cookie setting. There is a bug in the calculation of the size needed for a custom header called ``Browser-Cookie`` when using a Safari browser than sends cookies. An attacker can cause a heap overflow with a cookie that is too large. While this is a standard heap-based buffer overflow, there are preconditions required to reach the vulnerable code. This requires some type of reasoning ability and likely data flow analysis to generate an input to reach the code block. This is a good test to see how systems can handle additional precondition requirements.\r\n""","b'pov_harness, AddressSanitizer: heap-buffer-overflow\r\n'","b""#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n\r\n# Tests for user agent specific cookies module.\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib 'lib';\r\nuse Test::Nginx;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nmy $t = Test::Nginx->new()->has(qw/http charset/)->plan(4);\r\n\r\n$t->write_file_expand('nginx.conf', <<'EOF');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->write_file('t1.html', '<html><body>Hello world</body></html>');\r\n$t->run();\r\n\r\n###############################################################################\r\n\r\nmy $t1;\r\n\r\n$t1 = http_browser_cookie('/t1.html', 'Safari/1234 Mac OS X');\r\nlike($t1, qr/ 200 /, 'browser request - 200 good reply');\r\nlike($t1, qr/Browser-Cookie:/, 'browser request - found field');\r\n\r\n$t1 = http_browser_cookie('/t1.html', 'Firefox');\r\nlike($t1, qr/ 200 /, 'browser request - 200 good reply');\r\nunlike($t1, qr/Browser-Cookie:/, 'browser request - should not have found field');\r\n\r\n###############################################################################\r\n\r\nsub http_browser_cookie {\r\n\tmy ($url, $extra) = @_;\r\n\treturn http(<<EOF);\r\nGET $url HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\nCookie: foo\r\nUser-Agent: $extra\r\n\r\nEOF\r\n}\r\n\r\n###############################################################################\r\n""","b'diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c\r\nindex f7ab9aa..28016a6 100644\r\n--- a/src/http/ngx_http_core_module.c\r\n+++ b/src/http/ngx_http_core_module.c\r\n@@ -5263,43 +5263,7 @@ ngx_http_core_lowat_check(ngx_conf_t *cf, void *post, void *data)\r\n ngx_int_t\r\n ngx_http_set_browser_cookie(ngx_http_request_t *r)\r\n {\r\n-    ngx_table_elt_t           *browser_cookie;\r\n-\r\n-    if (!r->headers_in.safari && !r->headers_in.msie && !r->headers_in.chrome) {\r\n-        return NGX_OK;\r\n-    }\r\n-\r\n-    browser_cookie = ngx_list_push(&r->headers_out.headers);\r\n-    if (browser_cookie == NULL) {\r\n-        return NGX_ERROR;\r\n-    }\r\n-\r\n-    browser_cookie->hash = 1;\r\n-    browser_cookie->next = NULL;\r\n-    ngx_str_set(&browser_cookie->key, ""Browser-Cookie"");\r\n-\r\n-    browser_cookie->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3);\r\n-    if (browser_cookie->value.data == NULL) {\r\n-        browser_cookie->hash = 0;\r\n-        return NGX_ERROR;\r\n-    }\r\n-\r\n-    // Safari does not fully comply with RFC 2109 regarding cookies.\r\n-    if ( r->headers_in.safari && r->headers_in.cookie) {\r\n-        browser_cookie->value.len = ngx_sprintf(browser_cookie->value.data, ""\\""%xT-%xO\\"":%s"",\r\n-                                  r->headers_out.last_modified_time,\r\n-                                  r->headers_out.content_length_n,\r\n-                                  r->headers_in.cookie->value.data)\r\n-                                - browser_cookie->value.data; \r\n-    } else {\r\n-        browser_cookie->value.len = ngx_sprintf(browser_cookie->value.data, ""\\""%xT-%xO\\"""",\r\n-                                  r->headers_out.last_modified_time,\r\n-                                  r->headers_out.content_length_n)\r\n-                                - browser_cookie->value.data; \r\n-    }\r\n-    \r\n-\r\n-    return NGX_OK;\r\n+    return NGX_ERROR;\r\n }\r\n \r\n \r\n'","b'diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c\r\nindex f7ab9aa..47a992f 100644\r\n--- a/src/http/ngx_http_core_module.c\r\n+++ b/src/http/ngx_http_core_module.c\r\n@@ -5269,6 +5269,10 @@ ngx_http_set_browser_cookie(ngx_http_request_t *r)\r\n         return NGX_OK;\r\n     }\r\n \r\n+    if ( r->headers_in.cookie == NULL ) {\r\n+        return NGX_OK;\r\n+    }\r\n+\r\n     browser_cookie = ngx_list_push(&r->headers_out.headers);\r\n     if (browser_cookie == NULL) {\r\n         return NGX_ERROR;\r\n@@ -5278,7 +5282,7 @@ ngx_http_set_browser_cookie(ngx_http_request_t *r)\r\n     browser_cookie->next = NULL;\r\n     ngx_str_set(&browser_cookie->key, ""Browser-Cookie"");\r\n \r\n-    browser_cookie->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3);\r\n+    browser_cookie->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + r->headers_in.cookie->value.len + 3);\r\n     if (browser_cookie->value.data == NULL) {\r\n         browser_cookie->hash = 0;\r\n         return NGX_ERROR;\r\n'",b'GET / HTTP/1.1\nHost: localhost\nCookie: Whateverdogaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nUser-Agent: Safari/1234 Mac OS X\nAccept: */*\r\n\r\n'
cpv5,"b'# Overview\r\n\r\nID: cpv5     \r\nType: [CWE-476](https://cwe.mitre.org/data/definitions/476.html) Null Pointer Dereference     \r\nSanitizer: AddressSanitizer SEGV    \r\n\r\n# Details\r\n\r\nThe inject introduces counters at both the connection (``ngx_connection_t``) and request (``ngx_http_request_t``) levels. These counters are utilized to keep track of the total number of requests and connections processed by the server. A new structure, ``ngx_con_his_t``, is introduced, which is linked-listed to record details of each connection. This structure includes the address in text form (``addr_text``) and a pointer to the next history record (``next``). This feature allows NGINX to maintain a history of connections.\r\n\r\nModifications in ``ngx_http_core_module.c`` and ``ngx_http_static_module.c`` integrate the tracking logic. Specifically, the patch modifies the static handler to include cookie setting based on the browser type and integrates connection history handling directly within the event loop of the epoll module. This means each new connection increments the connection counter and potentially modifies the connection history chain. Two new functions, ``ngx_insert_con_his`` and ``ngx_get_con_his``, manage the connection history linked list. ``ngx_insert_con_his`` adds a new connection record to the history, while ``ngx_get_con_his`` retrieves a specific connection history record based on a sequential number which can be done by requesting the ``/lastConnection`` url.\r\n\r\nThis inject introduces a vulnerabily that is able to trigger a null-pointer-dereference within NGINX. By sending the URL `/lastConnection`, the server will respond with a string of the last IP to have connected, however, quering this URL the second time, will cause a poorly written `for-loop` to read a linked-list out of bounds dereference a null pointer. The included PoC simply causes a crash of the worker process. This CPV requires that the system is able to generate two requests in a single blob as well as understand how to maintain state across two requests. Additionally, it needs to understand the logic of traversing a linked list using a for loop.\r\n'","b'pov_harness, AddressSanitizer: SEGV\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n# (C) Valentin Bartenev\r\n\r\n# Tests for http variables.\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nmy $t = Test::Nginx->new()->has(qw/http rewrite proxy/)->plan(9);\r\n\r\n$t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nremote_admin on;\r\n\r\nevents {\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    log_format cc ""$uri: $sent_http_cache_control"";\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n\r\n        access_log %%TESTDIR%%/cc.log cc;\r\n\r\n        location / {\r\n            return 200 OK;\r\n        }\r\n\r\n    location /host_specs {\r\n            return 200 ""Host Specifications:\\n$host_specs"";\r\n        }\r\n\r\n        location /lastConnection {\r\n            return 200 ""Last IP: $last_ip"";\r\n        }\r\n\r\n        location /arg {\r\n            return 200 $arg_l:$arg_;\r\n        }\r\n\r\n        location /set {\r\n            add_header Cache-Control max-age=3600;\r\n            add_header Cache-Control private;\r\n            add_header Cache-Control must-revalidate;\r\n            return 200 OK;\r\n        }\r\n\r\n        location /redefine {\r\n            expires epoch;\r\n            proxy_pass http://127.0.0.1:8080/set;\r\n        }\r\n\r\n        location /limit_rate {\r\n            set $limit_rate $arg_l;\r\n            add_header X-Rate $limit_rate;\r\n            return 200 OK;\r\n        }\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->run();\r\n\r\n###############################################################################\r\nlike(http_get(\'/host_specs\'), qr/kB|Unknown MEM|Remote admin data is not allowed./, \'Host Specifications test\');\r\n\r\nlike(http_get(\'/lastConnection\'), qr/Last IP: 1/, \'Last IP test\');\r\n\r\nhttp_get(\'/\');\r\nhttp_get(\'/../bad_uri\');\r\nhttp_get(\'/redefine\');\r\n\r\nlike(http_get(\'/arg?l=42\'), qr/42:$/, \'arg\');\r\n\r\n# $limit_rate is a special variable that has its own set_handler / get_handler\r\n\r\nlike(http_get(\'/limit_rate?l=40k\'), qr/X-Rate: 40960/, \'limit_rate handlers\');\r\nlike(http_get(\'/limit_rate\'), qr/X-Rate: 0/, \'limit_rate invalid\');\r\n\r\n$t->stop();\r\n\r\nmy $log = $t->read_file(\'cc.log\');\r\nlike($log, qr!^: -$!m, \'no uri\');\r\nlike($log, qr!^/: -$!m, \'no header\');\r\nlike($log, qr!^/set: max-age=3600, private, must-revalidate$!m,\r\n\t\'multi headers\');\r\n\r\nlike($log, qr!^/redefine: no-cache$!m, \'ignoring headers with (hash == 0)\');\r\n\r\n###############################################################################\r\n'","b'diff --git a/src/core/ngx_cycle.c b/src/core/ngx_cycle.c\r\nindex d56a9be..c098e98 100644\r\n--- a/src/core/ngx_cycle.c\r\n+++ b/src/core/ngx_cycle.c\r\n@@ -56,18 +56,7 @@ ngx_insert_con_his(ngx_con_his_t **con_his_list, ngx_con_his_t *new_con)\r\n ngx_con_his_t *\r\n ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number)\r\n {\r\n-    ngx_con_his_t *target = con_his_list;\r\n-    size_t counter = 0;\r\n-\r\n-    if (!target || number == 1 || !number) {\r\n-        return target;\r\n-    }\r\n-\r\n-    for ( ; counter <= number; counter++) {\r\n-        target = target->next;\r\n-    }\r\n-\r\n-    return target;\r\n+    return NULL;\r\n }\r\n \r\n \r\ndiff --git a/src/http/ngx_http_variables.c b/src/http/ngx_http_variables.c\r\nindex b824058..a820dab 100644\r\n--- a/src/http/ngx_http_variables.c\r\n+++ b/src/http/ngx_http_variables.c\r\n@@ -2847,11 +2847,7 @@ static ngx_int_t\r\n ngx_http_get_last_ip_variable(ngx_http_request_t *r,\r\n     ngx_http_variable_value_t *v, uintptr_t data)\r\n {\r\n-    ngx_con_his_t *last_ip = ngx_get_con_his(r->connection_history, r->request_counter);\r\n-    v->data = last_ip->addr_text.data;\r\n-    v->len = last_ip->addr_text.len;\r\n-\r\n-    return NGX_OK;\r\n+    return NGX_ERROR;\r\n }\r\n \r\n \r\n'","b'diff --git a/src/core/ngx_cycle.c b/src/core/ngx_cycle.c\r\nindex d56a9be..0fd8297 100644\r\n--- a/src/core/ngx_cycle.c\r\n+++ b/src/core/ngx_cycle.c\r\n@@ -57,13 +57,12 @@ ngx_con_his_t *\r\n ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number)\r\n {\r\n     ngx_con_his_t *target = con_his_list;\r\n-    size_t counter = 0;\r\n \r\n     if (!target || number == 1 || !number) {\r\n         return target;\r\n     }\r\n \r\n-    for ( ; counter <= number; counter++) {\r\n+    for ( ; target && target->next; target++) {\r\n         target = target->next;\r\n     }\r\n \r\ndiff --git a/src/http/ngx_http_variables.c b/src/http/ngx_http_variables.c\r\nindex b824058..31c19e4 100644\r\n--- a/src/http/ngx_http_variables.c\r\n+++ b/src/http/ngx_http_variables.c\r\n@@ -2848,8 +2848,8 @@ ngx_http_get_last_ip_variable(ngx_http_request_t *r,\r\n     ngx_http_variable_value_t *v, uintptr_t data)\r\n {\r\n     ngx_con_his_t *last_ip = ngx_get_con_his(r->connection_history, r->request_counter);\r\n-    v->data = last_ip->addr_text.data;\r\n-    v->len = last_ip->addr_text.len;\r\n+    v->data = (last_ip) ? last_ip->addr_text.data : (u_char*)""NONE\\n"";\r\n+    v->len = (last_ip) ? last_ip->addr_text.len : 5;\r\n \r\n     return NGX_OK;\r\n }\r\n'","b'GET /lastConnection HTTP/1.1\r\nHost: localhost\r\nKeep-Alive: timeout=5, max=1000\r\n\r\n\r\nGET /lastConnection HTTP/1.1\r\nHost: localhost\r\nConnection: Close\r\n\r\n'"
cpv8,"b'# Overview\r\n\r\nID: cpv8<br>\r\nType: [CWE-787](https://cwe.mitre.org/data/definitions/787.html) Out of Bounds Write<br>\r\nSanitizer: AddressSanitizer: heap-buffer-overflow<br>\r\n\r\n# Details\r\n\r\nThe size of the temporary buffer created in the `ngx_mail_pop3_init_protocol` function is increased from 128 bytes to 1000 bytes. This change can accommodate larger data within the buffer during the POP3 protocol initialization. In the `ngx_mail_pop3_user` function, the allocation for `s->login.data` is changed from a dynamic allocation based on the length of the login argument to a fixed size allocation of 100 bytes. If the login data exceeds 100 bytes, it will overflow the allocated buffer (s->login.data). This could lead to overwriting adjacent memory, causing undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.<br>\r\n\r\nDifficulty to Discover (easy, medium, hard): Easy<br>\r\nDifficulty to Patch (easy, medium, hard): Easy<br>\r\n\r\nThis vulnerability is similar to others in syntax and can be recognized as an overflow quite easily. This is because it is commonm practice to avoid using a fixed size for memory allocation (Which is seen with `s->login.data`), so any seasoned code reviewer should notice that a fixed size is unnecessary since `s->login.len` contains the actual size of the buffer. <br>\r\n\r\nAn optimal patch for this vulnerability is simply to change the fixed size allocation of 100 bytes (which is arbitrary), to a dynamic allocation based on the length of the login argument (which is provided by `s->login.len`). This will make sure that a buffer overflow never occurs here, because we are allocating to the buffer the exact length that we need.<br>\r\n\r\nThis vulnerability causes NGINX to crash thus denying service to its clients. The intentional crash of a service is called ""Denial of Service"" or DoS.<br>\r\n'","b'mail_request_harness, AddressSanitizer: heap-buffer-overflow\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n\r\n# Tests for nginx mail pop3 module.\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\n\r\nuse MIME::Base64;\r\nuse Socket qw/ CRLF /;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\nuse Test::Nginx::POP3;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nlocal $SIG{PIPE} = \'IGNORE\';\r\n\r\nmy $t = Test::Nginx->new()->has(qw/mail pop3 http rewrite/)\r\n\t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nmail {\r\n    proxy_pass_error_message  on;\r\n    proxy_timeout  15s;\r\n    auth_http  http://127.0.0.1:8080/mail/auth;\r\n\r\n    server {\r\n        listen     127.0.0.1:8110;\r\n        protocol   pop3;\r\n        pop3_auth  plain apop cram-md5 external;\r\n    }\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n\r\n        location = /mail/auth {\r\n            set $reply ERROR;\r\n            set $passw """";\r\n\r\n            set $userpass ""$http_auth_user:$http_auth_pass"";\r\n            if ($userpass ~ \'^test@example.com:secret$\') {\r\n                set $reply OK;\r\n            }\r\n\r\n            set $userpass ""$http_auth_user:$http_auth_salt:$http_auth_pass"";\r\n            if ($userpass ~ \'^test@example.com:<.*@.*>:0{32}$\') {\r\n                set $reply OK;\r\n                set $passw secret;\r\n            }\r\n\r\n            set $userpass ""$http_auth_method:$http_auth_user:$http_auth_pass"";\r\n            if ($userpass ~ \'^external:test@example.com:$\') {\r\n                set $reply OK;\r\n                set $passw secret;\r\n            }\r\n\r\n            add_header Auth-Status $reply;\r\n            add_header Auth-Server 127.0.0.1;\r\n            add_header Auth-Port %%PORT_8111%%;\r\n            add_header Auth-Pass $passw;\r\n            add_header Auth-Wait 1;\r\n            return 204;\r\n        }\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->run_daemon(\\&Test::Nginx::POP3::pop3_test_daemon);\r\n$t->run()->plan(28);\r\n\r\n$t->waitforsocket(\'127.0.0.1:\' . port(8111));\r\n\r\n###############################################################################\r\n\r\nmy $s = Test::Nginx::POP3->new();\r\n$s->ok(\'greeting\');\r\n\r\n# user / pass\r\n\r\n$s->send(\'USER test@example.com\');\r\n$s->ok(\'user\');\r\n\r\n$s->send(\'PASS secret\');\r\n$s->ok(\'pass\');\r\n\r\n# apop\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->check(qr/<.*\\@.*>/, \'apop salt\');\r\n\r\n$s->send(\'APOP test@example.com \' . (\'1\' x 32));\r\n$s->check(qr/^-ERR/, \'apop error\');\r\n\r\n$s->send(\'APOP test@example.com \' . (\'0\' x 32));\r\n$s->ok(\'apop\');\r\n\r\n# auth capabilities\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH\');\r\n$s->ok(\'auth\');\r\n\r\nis(get_auth_caps($s), \'PLAIN:LOGIN:CRAM-MD5:EXTERNAL\', \'auth capabilities\');\r\n\r\n# auth plain\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH PLAIN \' . encode_base64(""\\0test\\@example.com\\0bad"", \'\'));\r\n$s->check(qr/^-ERR/, \'auth plain with bad password\');\r\n\r\n$s->send(\'AUTH PLAIN \' . encode_base64(""\\0test\\@example.com\\0secret"", \'\'));\r\n$s->ok(\'auth plain\');\r\n\r\n# auth login simple\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH LOGIN\');\r\n$s->check(qr/\\+ VXNlcm5hbWU6/, \'auth login username challenge\');\r\n\r\n$s->send(encode_base64(\'test@example.com\', \'\'));\r\n$s->check(qr/\\+ UGFzc3dvcmQ6/, \'auth login password challenge\');\r\n\r\n$s->send(encode_base64(\'secret\', \'\'));\r\n$s->ok(\'auth login simple\');\r\n\r\n# auth login with username\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH LOGIN \' . encode_base64(\'test@example.com\', \'\'));\r\n$s->check(qr/\\+ UGFzc3dvcmQ6/, \'auth login with username password challenge\');\r\n\r\n$s->send(encode_base64(\'secret\', \'\'));\r\n$s->ok(\'auth login with username\');\r\n\r\n# auth cram-md5\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH CRAM-MD5\');\r\n$s->check(qr/\\+ /, \'auth cram-md5 challenge\');\r\n\r\n$s->send(encode_base64(\'test@example.com \' . (\'0\' x 32), \'\'));\r\n$s->ok(\'auth cram-md5\');\r\n\r\n# auth external\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH EXTERNAL\');\r\n$s->check(qr/\\+ VXNlcm5hbWU6/, \'auth external challenge\');\r\n\r\n$s->send(encode_base64(\'test@example.com\', \'\'));\r\n$s->ok(\'auth external\');\r\n\r\n# auth external with username\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH EXTERNAL \' . encode_base64(\'test@example.com\', \'\'));\r\n$s->ok(\'auth external with username\');\r\n\r\n# pipelining\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'INVALID COMMAND WITH ARGUMENTS\' . CRLF\r\n\t. \'NOOP\');\r\n$s->check(qr/^-ERR/, \'pipelined invalid command\');\r\n$s->ok(\'pipelined noop after invalid command\');\r\n\r\n$s->send(\'USER test@example.com\' . CRLF\r\n\t. \'PASS secret\' . CRLF\r\n\t. \'QUIT\');\r\n$s->ok(\'pipelined user\');\r\n$s->ok(\'pipelined pass\');\r\n$s->ok(\'pipelined quit\');\r\n\r\n$s = Test::Nginx::POP3->new();\r\n$s->read();\r\n\r\n$s->send(\'AUTH LOGIN\' . CRLF\r\n\t. encode_base64(\'test@example.com\', \'\') . CRLF\r\n\t. encode_base64(\'secret\', \'\'));\r\n$s->check(qr/\\+ VXNlcm5hbWU6/, \'pipelined auth username challenge\');\r\n$s->check(qr/\\+ UGFzc3dvcmQ6/, \'pipelined auth password challenge\');\r\n$s->ok(\'pipelined auth\');\r\n\r\n###############################################################################\r\n\r\nsub get_auth_caps {\r\n\tmy ($s) = @_;\r\n\tmy @meth;\r\n\r\n\twhile ($s->read()) {\r\n\t\tlast if /^\\./;\r\n\t\tpush @meth, $1 if /(.*?)\\x0d\\x0a?/ms;\r\n\t}\r\n\tjoin \':\', @meth;\r\n}\r\n\r\n###############################################################################\r\n'","b'diff --git a/src/mail/ngx_mail_pop3_handler.c b/src/mail/ngx_mail_pop3_handler.c\r\nindex 3f4a214..508eae1 100644\r\n--- a/src/mail/ngx_mail_pop3_handler.c\r\n+++ b/src/mail/ngx_mail_pop3_handler.c\r\n@@ -315,33 +315,7 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\r\n static ngx_int_t\r\n ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)\r\n {\r\n-    ngx_str_t  *arg;\r\n-\r\n-#if (NGX_MAIL_SSL)\r\n-    if (ngx_mail_starttls_only(s, c)) {\r\n-        return NGX_MAIL_PARSE_INVALID_COMMAND;\r\n-    }\r\n-#endif\r\n-\r\n-    if (s->args.nelts != 1) {\r\n-        return NGX_MAIL_PARSE_INVALID_COMMAND;\r\n-    }\r\n-\r\n-    arg = s->args.elts;\r\n-    s->login.len = arg[0].len;\r\n-    s->login.data = ngx_pnalloc(c->pool, 100);\r\n-    if (s->login.data == NULL) {\r\n-        return NGX_ERROR;\r\n-    }\r\n-\r\n-    ngx_memcpy(s->login.data, arg[0].data, s->login.len);\r\n-\r\n-    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\r\n-                   ""pop3 login: \\""%V\\"""", &s->login);\r\n-\r\n-    s->mail_state = ngx_pop3_user;\r\n-\r\n-    return NGX_OK;\r\n+    return NGX_ERROR;\r\n }\r\n \r\n \r\n'","b'diff --git a/src/mail/ngx_mail_pop3_handler.c b/src/mail/ngx_mail_pop3_handler.c\r\nindex 3f4a214..1997255 100644\r\n--- a/src/mail/ngx_mail_pop3_handler.c\r\n+++ b/src/mail/ngx_mail_pop3_handler.c\r\n@@ -329,7 +329,7 @@ ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)\r\n \r\n     arg = s->args.elts;\r\n     s->login.len = arg[0].len;\r\n-    s->login.data = ngx_pnalloc(c->pool, 100);\r\n+    s->login.data = ngx_pnalloc(c->pool, s->login.len);\r\n     if (s->login.data == NULL) {\r\n         return NGX_ERROR;\r\n     }\r\n'",b'USER c4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fbc4c9334bac560ecc979e58001b3e22fb\r\n'
cpv9,"b'# Overview\r\n\r\nID: cpv9<br>\r\nType: [CWE-416](https://cwe.mitre.org/data/definitions/416.html)Use-After-Free<br>\r\nSanitizer: AddressSanitizer: Heap-Use-After-Free<br>\r\n\r\n# Details\r\n\r\nFor CPV-9, a feature of black-listing IPs was introduced to NGINX in `ngx_cycle.c`. This allows banning specific IPs and unbanning them. When ""white-listing"" or unbanning an IP, we fail to remove the object from the list, setting up a Use-After-Free. These errors cause a crash of the running process.<br>\r\n\r\nDifficulty to Discover (easy, medium, hard): Medium<br>\r\nDifficulty to Patch (easy, medium, hard): Medium<br>\r\n\r\nThe unchecked dereferencing of pointers is an easy to spot syntactical check. This vulnerability should be spotted fairly quickly. Now the incorrect removal of a dynamically allocated object from a list can take a little more analysis,for there is no one way to safely do so. You need to study the structure of the data that is being manipulated and understand how to clean it up after it is used.<br>\r\n\r\nTo mitigate these errors, we can use the provided macros `ngx_double_link_insert()`, `ngx_double_link_remove()`, and `ngx_destroy_black_list_link()` to safely interact with the objects in the list. We must also remember to check if a pointer is non-NULL before dereferencing.<br>\r\n\r\nThis vulnerability causes NGINX to crash thus denying service to its clients. The intentional crash of a service is called ""Denial of Service"" or DoS.<br>\r\n'","b'pov_harness, AddressSanitizer: heap-use-after-free\r\n'","b'#!/usr/bin/perl\r\n\r\n# (C) Maxim Dounin\r\n# (C) Nginx, Inc.\r\n\r\n# Tests for handling of multiple http headers and access via variables.\r\n\r\n###############################################################################\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\nuse Test::More;\r\nuse Socket qw/ CRLF /;\r\n\r\nBEGIN { use FindBin; chdir($FindBin::Bin); }\r\n\r\nuse lib \'lib\';\r\nuse Test::Nginx;\r\n\r\n###############################################################################\r\n\r\nselect STDERR; $| = 1;\r\nselect STDOUT; $| = 1;\r\n\r\nmy $t = Test::Nginx->new()->has(qw/http rewrite proxy/)->plan(43);\r\n\r\n$t->write_file_expand(\'nginx.conf\', <<\'EOF\');\r\n\r\n%%TEST_GLOBALS%%\r\n\r\ndaemon off;\r\n\r\nevents {\r\n}\r\n\r\nhttp {\r\n    %%TEST_GLOBALS_HTTP%%\r\n\r\n    server {\r\n        listen       127.0.0.1:8080;\r\n        server_name  localhost;\r\n\r\n        location / {\r\n            add_header X-Forwarded-For $http_x_forwarded_for;\r\n            add_header X-Cookie $http_cookie;\r\n            add_header X-Foo $http_foo;\r\n\r\n            add_header X-Cookie-Foo $cookie_foo;\r\n            add_header X-Cookie-Bar $cookie_bar;\r\n            add_header X-Cookie-Bazz $cookie_bazz;\r\n\r\n            return 204;\r\n        }\r\n\r\n        location /s {\r\n            add_header Cache-Control foo;\r\n            add_header Cache-Control bar;\r\n            add_header Cache-Control bazz;\r\n\r\n            add_header Link foo;\r\n            add_header Link bar;\r\n            add_header Link bazz;\r\n\r\n            add_header Foo foo;\r\n            add_header Foo bar;\r\n            add_header Foo bazz;\r\n\r\n            add_header X-Sent-CC $sent_http_cache_control;\r\n            add_header X-Sent-Link $sent_http_link;\r\n            add_header X-Sent-Foo $sent_http_foo;\r\n\r\n            return 204;\r\n        }\r\n\r\n        location /t {\r\n            add_trailer Foo foo;\r\n            add_trailer Foo bar;\r\n            add_trailer Foo bazz;\r\n            add_trailer X-Sent-Trailer-Foo $sent_trailer_foo;\r\n\r\n            return 200 """";\r\n        }\r\n\r\n        location /v {\r\n            add_header X-Forwarded-For $http_x_forwarded_for;\r\n            add_header X-Cookie $http_cookie;\r\n\r\n            add_header X-HTTP-Host $http_host;\r\n            add_header X-User-Agent $http_user_agent;\r\n            add_header X-Referer $http_referer;\r\n            add_header X-Via $http_via;\r\n\r\n            add_header X-Content-Length $content_length;\r\n            add_header X-Content-Type $content_type;\r\n            add_header X-Host $host;\r\n            add_header X-Remote-User $remote_user;\r\n\r\n            return 204;\r\n        }\r\n\r\n        location /d {\r\n            return 204;\r\n        }\r\n\r\n        location /u {\r\n            add_header X-Upstream-Set-Cookie $upstream_http_set_cookie;\r\n            add_header X-Upstream-Bar $upstream_http_bar;\r\n\r\n            add_header X-Upstream-Cookie-Foo $upstream_cookie_foo;\r\n            add_header X-Upstream-Cookie-Bar $upstream_cookie_bar;\r\n            add_header X-Upstream-Cookie-Bazz $upstream_cookie_bazz;\r\n\r\n            proxy_pass http://127.0.0.1:8080/backend;\r\n        }\r\n\r\n        location /backend {\r\n            add_header Set-Cookie foo=1;\r\n            add_header Set-Cookie bar=2;\r\n            add_header Set-Cookie bazz=3;\r\n            add_header Bar foo;\r\n            add_header Bar bar;\r\n            add_header Bar bazz;\r\n            return 204;\r\n        }\r\n    }\r\n}\r\n\r\nEOF\r\n\r\n$t->run();\r\n\r\n###############################################################################\r\n\r\n# combining multiple headers:\r\n#\r\n# $http_cookie, $http_x_forwarded_for, $sent_http_cache_control,\r\n# and $sent_http_link with special handling, other headers with\r\n# general handling\r\n\r\n# request headers, $http_*\r\n\r\nlike(get(\'/\', map { ""X-Forwarded-For: $_"" } qw/ foo bar bazz /),\r\n\tqr/X-Forwarded-For: foo, bar, bazz/, \'multi $http_x_forwarded_for\');\r\nlike(get(\'/\', \'Cookie: foo=1\', \'Cookie: bar=2\', \'Cookie: bazz=3\'),\r\n\tqr/X-Cookie: foo=1; bar=2; bazz=3/, \'multi $http_cookie\');\r\n\r\nTODO: {\r\nlocal $TODO = \'not yet\' unless $t->has_version(\'1.23.0\');\r\n\r\nlike(get(\'/\', \'Foo: foo\', \'Foo: bar\', \'Foo: bazz\'),\r\n\tqr/X-Foo: foo, bar, bazz/, \'multi $http_foo\');\r\n\r\n}\r\n\r\n# request cookies, $cookie_*\r\n\r\nmy $r = get(\'/\', \'Cookie: foo=1\', \'Cookie: bar=2\', \'Cookie: bazz=3\');\r\n\r\nlike($r, qr/X-Cookie-Foo: 1/, \'$cookie_foo\');\r\nlike($r, qr/X-Cookie-Bar: 2/, \'$cookie_bar\');\r\nlike($r, qr/X-Cookie-Bazz: 3/, \'$cookie_bazz\');\r\n\r\n# response headers, $http_*\r\n\r\n$r = get(\'/s\');\r\n\r\nlike($r, qr/X-Sent-CC: foo, bar, bazz/, \'multi $sent_http_cache_control\');\r\nlike($r, qr/X-Sent-Link: foo, bar, bazz/, \'multi $sent_http_link\');\r\n\r\nTODO: {\r\nlocal $TODO = \'not yet\' unless $t->has_version(\'1.23.0\');\r\n\r\nlike($r, qr/X-Sent-Foo: foo, bar, bazz/, \'multi $sent_http_foo\');\r\n\r\n}\r\n\r\n# upstream response headers, $upstream_http_*\r\n\r\n$r = get(\'/u\');\r\n\r\nTODO: {\r\nlocal $TODO = \'not yet\' unless $t->has_version(\'1.23.0\');\r\n\r\nlike($r, qr/X-Upstream-Set-Cookie: foo=1, bar=2, bazz=3/,\r\n\t\'multi $upstream_http_set_cookie\');\r\nlike($r, qr/X-Upstream-Bar: foo, bar, bazz/, \'multi $upstream_http_bar\');\r\n\r\n}\r\n\r\n# upstream response cookies, $upstream_cookie_*\r\n\r\nlike($r, qr/X-Upstream-Cookie-Foo: 1/, \'$upstream_cookie_foo\');\r\nlike($r, qr/X-Upstream-Cookie-Bar: 2/, \'$upstream_cookie_bar\');\r\nlike($r, qr/X-Upstream-Cookie-Bazz: 3/, \'$upstream_cookie_bazz\');\r\n\r\n# response trailers, $sent_trailer_*\r\n\r\nTODO: {\r\nlocal $TODO = \'not yet\' unless $t->has_version(\'1.23.0\');\r\n\r\nlike(get(\'/t\'), qr/X-Sent-Trailer-Foo: foo, bar, bazz/,\r\n\t\'multi $sent_trailer_foo\');\r\n\r\n}\r\n\r\n# various variables for request headers:\r\n#\r\n# $http_host, $http_user_agent, $http_referer\r\n# multiple Host, User-Agent, Referer headers are invalid, but we currently\r\n# reject only requests with multiple Host headers\r\n#\r\n# $http_via, $http_x_forwarded_for, $http_cookie\r\n# multiple headers are valid\r\n\r\nlike(get(\'/v\'), qr/X-HTTP-Host: localhost/, \'$http_host\');\r\nlike(get(\'/v\', \'Host: foo\', \'Host: bar\'),\r\n\tqr/400 Bad/, \'duplicate host rejected\');\r\n\r\nTODO: {\r\nlocal $TODO = \'not yet\' unless $t->has_version(\'1.23.0\');\r\n\r\nlike(get(\'/v\', \'User-Agent: foo\', \'User-Agent: bar\'),\r\n\tqr/X-User-Agent: foo, bar/, \'multi $http_user_agent (invalid)\');\r\nlike(get(\'/v\', \'Referer: foo\', \'Referer: bar\'),\r\n\tqr/X-Referer: foo, bar/, \'multi $http_referer (invalid)\');\r\nlike(get(\'/v\', \'Via: foo\', \'Via: bar\', \'Via: bazz\'),\r\n\tqr/X-Via: foo, bar, bazz/, \'multi $http_via\');\r\n\r\n}\r\n\r\nlike(get(\'/v\', \'Cookie: foo\', \'Cookie: bar\', \'Cookie: bazz\'),\r\n\tqr/X-Cookie: foo; bar; bazz/, \'multi $http_cookie\');\r\nlike(get(\'/v\', \'X-Forwarded-For: foo\', \'X-Forwarded-For: bar\',\r\n\t\'X-Forwarded-For: bazz\'),\r\n\tqr/X-Forwarded-For: foo, bar, bazz/, \'multi $http_x_forwarded_for\');\r\n\r\n# other variables related to request headers:\r\n#\r\n# $content_length, $content_type, $host, $remote_user\r\n\r\nlike(get(\'/v\', \'Content-Length: 0\'),\r\n\tqr/X-Content-Length: 0/, \'$content_length\');\r\nlike(get(\'/v\', \'Content-Length: 0\', \'Content-Length: 0\'),\r\n\tqr/400 Bad/, \'duplicate Content-Length rejected\');\r\n\r\nlike(get(\'/v\', \'Content-Type: foo\'),\r\n\tqr/X-Content-Type: foo/, \'$content_type\');\r\n\r\nTODO: {\r\nlocal $TODO = \'not yet\' unless $t->has_version(\'1.23.0\');\r\n\r\nlike(get(\'/v\', \'Content-Type: foo\', \'Content-Type: bar\'),\r\n\tqr/X-Content-Type: foo, bar/, \'multi $content_type (invalid)\');\r\n\r\n}\r\n\r\nlike(http(""GET /v HTTP/1.0"" . CRLF . CRLF),\r\n\tqr/X-Host: localhost/, \'$host from server_name\');\r\nlike(http(""GET /v HTTP/1.0"" . CRLF . ""Host: foo"" . CRLF . CRLF),\r\n\tqr/X-Host: foo/, \'$host\');\r\nlike(http(""GET /v HTTP/1.0"" . CRLF . ""Host: foo"" . CRLF .\r\n\t""Host: bar"" . CRLF . CRLF),\r\n\tqr/400 Bad/, \'duplicate host rejected\');\r\n\r\nlike(get(\'/v\', \'Authorization: Basic dXNlcjpzZWNyZXQ=\'),\r\n\tqr/X-Remote-User: user/, \'$remote_user\');\r\nlike(get(\'/v\', \'Authorization: Basic dXNlcjpzZWNyZXQ=\',\r\n\t\'Authorization: Basic dXNlcjpzZWNyZXQ=\'),\r\n\tqr/400 Bad/, \'duplicate authorization rejected\');\r\n\r\n# request headers required to be unique:\r\n#\r\n# Host, If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match,\r\n# Content-Length, Content-Range, If-Range, Transfer-Encoding, Expect,\r\n# Authorization\r\n\r\nlike(get(\'/d\', \'Host: foo\', \'Host: bar\'),\r\n\tqr/400 Bad/, \'duplicate Host rejected\');\r\nlike(get(\'/d\', \'If-Modified-Since: foo\', \'If-Modified-Since: bar\'),\r\n\tqr/400 Bad/, \'duplicate If-Modified-Since rejected\');\r\nlike(get(\'/d\', \'If-Unmodified-Since: foo\', \'If-Unmodified-Since: bar\'),\r\n\tqr/400 Bad/, \'duplicate If-Unmodified-Since rejected\');\r\nlike(get(\'/d\', \'If-Match: foo\', \'If-Match: bar\'),\r\n\tqr/400 Bad/, \'duplicate If-Match rejected\');\r\nlike(get(\'/d\', \'If-None-Match: foo\', \'If-None-Match: bar\'),\r\n\tqr/400 Bad/, \'duplicate If-None-Match rejected\');\r\nlike(get(\'/d\', \'Content-Length: 0\', \'Content-Length: 0\'),\r\n\tqr/400 Bad/, \'duplicate Content-Length rejected\');\r\nlike(get(\'/d\', \'Content-Range: foo\', \'Content-Range: bar\'),\r\n\tqr/400 Bad/, \'duplicate Content-Range rejected\');\r\nlike(get(\'/d\', \'If-Range: foo\', \'If-Range: bar\'),\r\n\tqr/400 Bad/, \'duplicate If-Range rejected\');\r\nlike(get(\'/d\', \'Transfer-Encoding: foo\', \'Transfer-Encoding: bar\'),\r\n\tqr/400 Bad/, \'duplicate Transfer-Encoding rejected\');\r\nlike(get(\'/d\', \'Expect: foo\', \'Expect: bar\'),\r\n\tqr/400 Bad/, \'duplicate Expect rejected\');\r\nlike(get(\'/d\', \'Authorization: foo\', \'Authorization: bar\'),\r\n\tqr/400 Bad/, \'duplicate Authorization rejected\');\r\nlike(get(\'/\', \'Black-List: 111.111.111.111;222.222.222.222;333.333.333.333;\',\r\n              \'White-List: 222.222.222.222;111.111.111.111;\'),\r\n    qr/204 No Content/, \'Black list/White list IPs\');\r\n\r\n###############################################################################\r\n\r\nsub get {\r\n\tmy ($url, @headers) = @_;\r\n\treturn http(\r\n\t\t""GET $url HTTP/1.1"" . CRLF .\r\n\t\t\'Host: localhost\' . CRLF .\r\n\t\t\'Connection: close\' . CRLF .\r\n\t\tjoin(CRLF, @headers) . CRLF . CRLF\r\n\t);\r\n}\r\n\r\n###############################################################################\r\n'","b'diff --git a/src/core/ngx_cycle.c b/src/core/ngx_cycle.c\r\nindex d56a9be..48278ce 100644\r\n--- a/src/core/ngx_cycle.c\r\n+++ b/src/core/ngx_cycle.c\r\n@@ -1656,23 +1656,6 @@ ngx_black_list_insert(ngx_black_list_t **black_list, u_char insert_ip[],\r\n ngx_int_t\r\n ngx_black_list_remove(ngx_black_list_t **black_list, u_char remove_ip[])\r\n {\r\n-    ngx_black_list_t *reader;\r\n-\r\n-    reader = *black_list;\r\n-\r\n-    if (reader && !ngx_strcmp(remove_ip, reader->IP->data)) {\r\n-        ngx_destroy_black_list_link(reader);\r\n-        return NGX_OK;\r\n-    }\r\n-\r\n-    for (reader = reader->next; reader && reader->next; reader = reader->next) {\r\n-        if (!ngx_strcmp(remove_ip, reader->IP->data)) {\r\n-            ngx_double_link_remove(reader);\r\n-            ngx_destroy_black_list_link(reader);\r\n-            return NGX_OK;\r\n-        }\r\n-    }\r\n-\r\n     return NGX_ERROR;\r\n }\r\n \r\n'","b'diff --git a/src/core/ngx_cycle.c b/src/core/ngx_cycle.c\r\nindex d56a9be..3e25dca 100644\r\n--- a/src/core/ngx_cycle.c\r\n+++ b/src/core/ngx_cycle.c\r\n@@ -1626,10 +1626,10 @@ ngx_black_list_insert(ngx_black_list_t **black_list, u_char insert_ip[],\r\n     }\r\n \r\n     new_black_list = (ngx_black_list_t*)ngx_alloc(sizeof(ngx_black_list_t), log);\r\n+    ngx_memzero(new_black_list, sizeof(ngx_black_list_t));\r\n     new_black_list->IP = (ngx_str_t*)ngx_alloc(sizeof(ngx_str_t), log);;\r\n     new_black_list->IP->data = new_str;\r\n     new_black_list->IP->len = size;\r\n-    new_black_list->next = NULL;\r\n \r\n     reader = *black_list;\r\n \r\n@@ -1638,7 +1638,7 @@ ngx_black_list_insert(ngx_black_list_t **black_list, u_char insert_ip[],\r\n         return;\r\n     }\r\n \r\n-    for (reader = reader; reader && reader->next; reader = reader->next) {\r\n+    for ( ; reader && reader->next; reader = reader->next) {\r\n \r\n          if (!ngx_strcmp(insert_ip, reader->IP->data)) {\r\n             ngx_destroy_black_list_link(new_black_list);\r\n@@ -1646,8 +1646,7 @@ ngx_black_list_insert(ngx_black_list_t **black_list, u_char insert_ip[],\r\n          }\r\n     }\r\n \r\n-    reader->next = new_black_list;\r\n-    new_black_list->prev = reader;\r\n+    ngx_double_link_insert(reader, new_black_list);\r\n \r\n     return;\r\n }\r\n@@ -1661,12 +1660,20 @@ ngx_black_list_remove(ngx_black_list_t **black_list, u_char remove_ip[])\r\n     reader = *black_list;\r\n \r\n     if (reader && !ngx_strcmp(remove_ip, reader->IP->data)) {\r\n+        if (!reader->prev) {\r\n+            *black_list = reader->next;\r\n+            ngx_double_link_remove(reader);\r\n+            ngx_destroy_black_list_link(reader);\r\n+            return NGX_OK;\r\n+        }\r\n+\r\n+        ngx_double_link_remove(reader);\r\n         ngx_destroy_black_list_link(reader);\r\n         return NGX_OK;\r\n     }\r\n \r\n-    for (reader = reader->next; reader && reader->next; reader = reader->next) {\r\n-        if (!ngx_strcmp(remove_ip, reader->IP->data)) {\r\n+    for ( ; reader; reader = reader->next) {\r\n+        if (reader->IP && !ngx_strcmp(remove_ip, reader->IP->data)) {\r\n             ngx_double_link_remove(reader);\r\n             ngx_destroy_black_list_link(reader);\r\n             return NGX_OK;\r\n@@ -1682,10 +1689,9 @@ ngx_is_ip_banned(ngx_cycle_t *cycle, ngx_connection_t *connection)\r\n {\r\n     ngx_black_list_t *reader = (cycle) ? cycle->black_list : NULL;\r\n \r\n-    for (reader = reader; reader; reader = reader->next) {\r\n-            if (!ngx_strcmp(connection->addr_text.data, reader->IP->data)) {\r\n+    for ( ; reader; reader = reader->next) {\r\n+            if (reader->IP && !ngx_strcmp(connection->addr_text.data, reader->IP->data)) {\r\n                 ngx_close_connection(connection);\r\n-                return NGX_ERROR;\r\n             }\r\n     }\r\n \r\n'",b'GET / HTTP/1.1\r\nHost: localhost:9999\r\nUser-Agent: curl/7.81.0\r\nAccept: */*\r\nBlack-List: 111.111.111.111;222.222.222.222;333.333.333.333;\r\nWhite-List: 111.111.111.111;222.222.222.222;\r\n\r\n'
